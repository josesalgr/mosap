[{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"experimental-settings","dir":"Articles","previous_headings":"","what":"Experimental settings","title":"Solver benchmarks","text":"analysis encompassed generation prioritizations solvers available prioriactions, accompanied measuring time quality solutions (gap) solver required complete process. explored set management planning problems characterized distinct models (referred models (), (B), (C)). Among models considered, (C) stands largest model due incorporation spatial connectivity requirements actions (blmkblm_k = 0.8). contrast, model (B) entails connectivity solely management units (blmblm = 0.8), model () lacks form spatial requirement. Consequently, solving model () comparatively straightforward, given absence spatial constraints (elaborated Table model sizes). Also, introduce variations target achievement levels (10%, 20%, 30%, 40% respectively), thereby altering inherent attributes models. benchmark scenarios encompassed Mitchell River case study presented, .e. 2,316 planning units, 45 features, 4 threats. Model size (Variables, Constraints, Nonzeros elements constraint matrix) different modelling scenarios. experimental setup conducted machine powered Intel Core i5-1240P 3.30GHz processor, paired 16 GB RAM LPDDR5-6400MHz, running Ubuntu 22.04 LTS. Firstly, time_limit parameter, designates maximum period solver dedicates pursuing optimal solution, set 10,800 seconds, equivalent span 3 hours. noteworthy constraint placed gap achieve (gap_limit = 0}), underscoring aim attaining utmost optimal solution within aforementioned three-hour timeframe. Secondly, number cores utilized set ten. Futhermore, employed recent versions available optimizers within prioriactions framework. Specifically, BM CPLEX, utilized version 22.1.1.0 conjunction Rcplex version 0.3.7. Gurobi employed version 10.0.0, Rcbc utilized version 0.1.0.9001. Additionally, symphony, leveraged Rsymphony version 0.1-33 ensure comprehensive --date foundation analyses. derive outcomes, solely adjusted third step, involving alteration solver’s name within solve() function embedded prioriactions package. subsequent segments, offer distinct log outputs corresponding experimental solvers operating within scenario (), recovery target set 10%. log records serve illustrative examples, providing insight information presented throughout optimization process.","code":"# solve the model solution <- solve(model, solver = \"gurobi\", gap_limit = 0, time_limit = 10800,                    solution_limit = FALSE, cores = 10, output_file = TRUE, verbose = TRUE)"},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"gurobi","dir":"Articles","previous_headings":"Experimental settings","what":"Gurobi","title":"Solver benchmarks","text":"logs follow consistent structure, albeit variations based information presented manner presentation. structure can succinctly summarized four key sections: () optimizer settings; initial part includes details settings configurations optimizer (lines 1 8). (ii) presolve; fine-tune model. step involves searching bounds associated relaxed solution (infeasible), among tasks (lines 15 31). (iii) solutions search; entails active pursuit optimal solution (one optimal solutions, multiple exist, lines 33 61). , (iv) summary; summarises entire optimization process, providing quality gaps times, among things (lines 63 69). particular instance, optimal solution (gap 0.00%) successfully attained, yielding value 646, 10 seconds process started.","code":"1  Gurobi 10.0.0 (linux64, R) logging started dom 06 ago 2023 19:49:56 2  3  Set parameter Username 4  Set parameter TimeLimit to value 10800 5  Set parameter MIPGap to value 0 6  Set parameter NodefileStart to value 0.5 7  Set parameter LogFile to value \"modelA_10_gurobi_log.txt\" 8  Set parameter Threads to value 10 9  Academic license - for non-commercial use only - expires 2024-01-25 10 Gurobi Optimizer version 10.0.0 build v10.0.0rc2 (linux64) 11 12 CPU model: 12th Gen Intel(R) Core(TM) i5-1240P, instruction set [SSE2|AVX|AVX2] 13 Thread count: 16 physical cores, 16 logical processors, using up to 10 threads 14 15 Optimize a model with 37371 rows, 43180 columns and 136566 nonzeros 16 Model fingerprint: 0x96123de4 17 Variable types: 34965 continuous, 8215 integer (8215 binary) 18 Coefficient statistics: 19   Matrix range     [3e-01, 4e+00] 20   Objective range  [1e+00, 1e+00] 21   Bounds range     [1e+00, 1e+00] 22   RHS range        [5e-01, 2e+02] 23 Found heuristic solution: objective 7947.0000000 24 Found heuristic solution: objective 4978.0000000 25 Presolve removed 35017 rows and 35259 columns 26 Presolve time: 0.15s 27 Presolved: 2354 rows, 7921 columns, 66284 nonzeros 28 Variable types: 0 continuous, 7921 integer (7904 binary) 29 Found heuristic solution: objective 817.0000000 30  31 Root relaxation: objective 5.657750e+02, 3822 iterations, 0.05 seconds (0.26 work units) 32  33     Nodes    |    Current Node    |     Objective Bounds      |     Work 34  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time 35  36      0     0  565.77500    0  279  817.00000  565.77500  30.7%     -    0s 37 H    0     0                     699.0000000  565.77500  19.1%     -    0s 38 H    0     0                     663.0000000  565.77500  14.7%     -    0s 39 H    0     0                     651.0000000  565.77500  13.1%     -    0s 40      0     0  573.58333    0  399  651.00000  573.58333  11.9%     -    0s 41      0     0  575.33333    0  387  651.00000  575.33333  11.6%     -    0s 42      0     0  577.54167    0  457  651.00000  577.54167  11.3%     -    1s 43      0     0  580.01543    0  429  651.00000  580.01543  10.9%     -    1s 44 H    0     0                     647.0000000  580.51543  10.3%     -    1s 45      0     0  580.51543    0  434  647.00000  580.51543  10.3%     -    1s 46      0     0  580.51543    0  431  647.00000  580.51543  10.3%     -    1s 47      0     0  590.16667    0  350  647.00000  590.16667  8.78%     -    1s 48      0     0  590.26667    0  334  647.00000  590.26667  8.77%     -    1s 49      0     0  590.26667    0  327  647.00000  590.26667  8.77%     -    1s 50      0     0  599.85185    0  258  647.00000  599.85185  7.29%     -    1s 51      0     0  603.87037    0  236  647.00000  603.87037  6.67%     -    1s 52      0     0  614.47222    0  161  647.00000  614.47222  5.03%     -    1s 53      0     0  614.47222    0  158  647.00000  614.47222  5.03%     -    1s 54      0     0  614.72222    0  130  647.00000  614.72222  4.99%     -    1s 55      0     0  614.72222    0  146  647.00000  614.72222  4.99%     -    1s 56      0     0  614.72222    0  194  647.00000  614.72222  4.99%     -    1s 57      0     0  614.72222    0  160  647.00000  614.72222  4.99%     -    2s 58 H    0     0                     646.0000000  614.72222  4.84%     -    2s 59      0     2  614.72222    0  160  646.00000  614.72222  4.84%     -    2s 60   1966  2055  630.50000  123   31  646.00000  626.33333  3.04%   9.7    5s 61   7481  7363  630.50000  460   43  646.00000  626.33333  3.04%   7.2   10s 62  63 Explored 8192 nodes (87667 simplex iterations) in 11.58 seconds (16.40 work units) 64 Thread count was 10 (of 16 available processors) 65  66 Solution count 8: 646 647 651 ... 7947 67  68 Optimal solution found (tolerance 0.00e+00) 69 Best objective 6.460000000000e+02, best bound 6.460000000000e+02, gap 0.0000%"},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"cplex","dir":"Articles","previous_headings":"Experimental settings","what":"CPLEX","title":"Solver benchmarks","text":"Similar gurobi, CPLEX log adheres closely outlined structure. Precisely, lines 3 9 correspond (), lines 10 30 encompass (ii). Furthermore, lines 31 49 represent (iii), lines 51 63 represent (iv). context, optimal solution swiftly identified within mere 2.08 seconds maintaining identical objective value 646.","code":"1  CPLEX environment opened 2  Warning: The following options are not availables using cplex solver: output_file 3  Rcplex: num variables=43180 num constraints=37371 4  Version identifier: 22.1.1.0 | 2022-11-28 | 9160aff4d 5  CPXPARAM_TimeLimit                               10800 6  CPXPARAM_MIP_Tolerances_AbsMIPGap                0 7  CPXPARAM_MIP_Tolerances_MIPGap                   0 8  CPXPARAM_MIP_Pool_RelGap                         0 9  CPXPARAM_MIP_Pool_AbsGap                         0 10 Found incumbent of value 8215.000000 after 0.00 sec. (2.35 ticks) 11 Tried aggregator 4 times. 12 MIP Presolve eliminated 1402 rows and 300 columns. 13 MIP Presolve added 2688 rows and 0 columns. 14 MIP Presolve modified 354 coefficients. 15 Aggregator did 34959 substitutions. 16 Reduced MIP has 3698 rows, 7921 columns, and 67628 nonzeros. 17 Reduced MIP has 7904 binaries, 17 generals, 0 SOSs, and 0 indicators. 18 Presolve time = 0.39 sec. (1525.39 ticks) 19 Probing time = 0.00 sec. (2.02 ticks) 20 Tried aggregator 1 time. 21 Detecting symmetries... 22 Reduced MIP has 3698 rows, 7921 columns, and 67628 nonzeros. 23 Reduced MIP has 7904 binaries, 17 generals, 0 SOSs, and 0 indicators. 24 Presolve time = 0.03 sec. (51.39 ticks) 25 Probing time = 0.01 sec. (2.02 ticks) 26 Clique table members: 5591. 27 MIP emphasis: balance optimality and feasibility. 28 MIP search method: dynamic search. 29 Parallel mode: deterministic, using up to 16 threads. 30 Root relaxation solution time = 0.06 sec. (98.92 ticks) 31         Nodes                                         Cuts/ 32    Node  Left     Objective  IInf  Best Integer    Best Bound    ItCnt     Gap 33  34 *     0+    0                         7947.0000        0.0000           100.00% 35 *     0+    0                          925.0000        0.0000           100.00% 36 *     0+    0                          768.0000        0.0000           100.00% 37       0     0      566.4167   353      768.0000      566.4167     2719   26.25% 38 *     0+    0                          766.0000      566.4167            26.06% 39       0     0      577.0000   387      766.0000     Cuts: 453     3327   24.67% 40 *     0+    0                          651.0000      577.0000            11.37% 41       0     0      581.0833   361      651.0000     Cuts: 384     3778   10.74% 42       0     0      592.9111   293      651.0000     Cuts: 356     4484    8.92% 43 *     0+    0                          646.0000      592.9111             8.22% 44       0     0  -1.00000e+75     0      646.0000      592.9111     4484    8.22% 45       0     0      604.6852   207      646.0000     Cuts: 279     5004    6.40% 46       0     0      608.2222   170      646.0000     Cuts: 189     5264    5.85% 47       0     0      637.3333    13      646.0000     Cuts: 161     5393    1.34% 48       0     0        cutoff            646.0000                   5406    0.00% 49 Elapsed time = 2.07 sec. (2723.02 ticks, tree = 0.01 MB, solutions = 1) 50  51 Clique cuts applied:  447 52 Cover cuts applied:  1269 53 Mixed integer rounding cuts applied:  3 54 Zero-half cuts applied:  56 55  56 Root node processing (before b&c): 57   Real time             =    2.08 sec. (2724.47 ticks) 58 Parallel b&c, 16 threads: 59   Real time             =    0.00 sec. (0.00 ticks) 60   Sync time (average)   =    0.00 sec. 61   Wait time (average)   =    0.00 sec. 62                           ------------ 63 Total (root+branch&cut) =    2.08 sec. (2724.47 ticks)"},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"cbc","dir":"Articles","previous_headings":"Experimental settings","what":"CBC","title":"Solver benchmarks","text":"case CBC solver, log provides even higher specificity level counterparts gurobi CPLEX. instance, breakdown follows: lines 5 11 correspond (), offering initial insights. Lines 12 66 delve intricate detailed aspects presolve (ii). Subsequently, lines 67 80 represent (iii). along, lines 81 110 illustrate (iv). Note employed stopping criterion set 3600 seconds. decision stems understanding non-academic solver, optimal solution might attained within shorter timeframe (indeed case). approach ensures able present complete structure log output comprehensively. Thus, optimal solution reached (gap 0.04%). Instead, found solution objective value 653, marking distinction previous solvers’ outcomes, converged 646.","code":"1   Welcome to the CBC MILP Solver  2   Version: 2.10.5  3   Build Date: Apr 21 2021  4 5   command line - problem -threads 10 -log 1 -verbose 15 -ratio 0 -sec 10800 -timem elapsed  6   -heuristicsOnOff on -solve -quit (default strategy 1) 7   verbose was changed from 0 to 15 8   ratioGap was changed from 0 to 0 9   seconds was changed from 1e+100 to 10800 10   Option for timeMode changed from cpu to elapsed 11  Option for heuristicsOnOff changed from off to on 12  Continuous objective value is 563.542 - 8.95 seconds 13  Cgl0004I processed model has 37313 rows, 42882 columns (7930 integer (7914 of which binary))  14  and 136210 elements 15  Cbc0038I Initial state - 372 integers unsatisfied sum - 123.042 16  Cbc0038I Pass   1: (9.34 seconds) suminf.   79.66667 (242) obj. 604.667 iterations 720 17  Cbc0038I Pass   2: (9.36 seconds) suminf.   78.16667 (239) obj. 606.167 iterations 3 18  Cbc0038I Pass   3: (9.39 seconds) suminf.   71.16667 (218) obj. 620.167 iterations 21 19  Cbc0038I Pass   4: (9.41 seconds) suminf.   63.83333 (196) obj. 634.833 iterations 22 20  Cbc0038I Pass   5: (9.44 seconds) suminf.   56.16667 (173) obj. 650.167 iterations 23 21  Cbc0038I Pass   6: (9.46 seconds) suminf.   46.50000 (144) obj. 669.5 iterations 29 22  Cbc0038I Pass   7: (9.49 seconds) suminf.   38.16667 (119) obj. 686.167 iterations 25 23  Cbc0038I Pass   8: (9.52 seconds) suminf.   33.83333 (106) obj. 694.833 iterations 13 24  Cbc0038I Pass   9: (9.54 seconds) suminf.   25.50000 (81) obj. 711.5 iterations 25 25  Cbc0038I Pass  10: (9.57 seconds) suminf.   18.16667 (59) obj. 726.167 iterations 22 26  Cbc0038I Pass  11: (9.59 seconds) suminf.   13.16667 (44) obj. 736.167 iterations 15 27  Cbc0038I Pass  12: (9.62 seconds) suminf.    7.50000 (27) obj. 747.5 iterations 17 28  Cbc0038I Pass  13: (9.64 seconds) suminf.    1.16667 (7) obj. 761.167 iterations 20 29  Cbc0038I Solution found of 767 30  Cbc0038I Relaxing continuous gives 767 31  Cbc0038I Cleaned solution of 767 32  Cbc0038I Before mini branch and bound, 7554 integers at bound fixed and 31499 continuous 33  Cbc0038I Full problem 37313 rows 42882 columns, reduced to 262 rows 253 columns 34  Cbc0038I Mini branch and bound improved solution from 767 to 765 (9.83 seconds) 35  Cbc0038I Round again with cutoff of 744.104 36  Cbc0038I Pass  14: (9.91 seconds) suminf.   79.66667 (242) obj. 604.667 iterations 0 37  Cbc0038I Pass  15: (9.94 seconds) suminf.   73.50000 (225) obj. 615.5 iterations 17 38  Cbc0038I Pass  16: (9.96 seconds) suminf.   64.83333 (199) obj. 632.833 iterations 26 39  Cbc0038I Pass  17: (9.99 seconds) suminf.   60.50000 (186) obj. 641.5 iterations 13 40  Cbc0038I Pass  18: (10.01 seconds) suminf.   56.16667 (173) obj. 650.167 iterations 13 41  Cbc0038I Pass  19: (10.04 seconds) suminf.   47.83333 (148) obj. 666.833 iterations 25 42  Cbc0038I Pass  20: (10.07 seconds) suminf.   39.50000 (123) obj. 683.5 iterations 25 43  Cbc0038I Pass  21: (10.09 seconds) suminf.   31.16667 (98) obj. 700.167 iterations 25 44  Cbc0038I Pass  22: (10.12 seconds) suminf.   25.83333 (82) obj. 710.833 iterations 16 45  Cbc0038I Pass  23: (10.14 seconds) suminf.   19.16667 (62) obj. 724.167 iterations 20 46  Cbc0038I Pass  24: (10.17 seconds) suminf.    9.83333 (34) obj. 742.833 iterations 28 47  Cbc0038I Pass  25: (10.21 seconds) suminf.   10.69574 (36) obj. 744.104 iterations 206 48  Cbc0038I Pass  26: (10.24 seconds) suminf.   10.12908 (36) obj. 744.104 iterations 48 49  Cbc0038I Pass  27: (10.28 seconds) suminf.    9.67908 (35) obj. 744.104 iterations 144 50  Cbc0038I Pass  28: (10.31 seconds) suminf.   10.69574 (34) obj. 744.104 iterations 26 51  Cbc0038I Pass  29: (10.34 seconds) suminf.   10.67908 (37) obj. 744.104 iterations 16 52  Cbc0038I Pass  30: (10.36 seconds) suminf.   10.67908 (37) obj. 744.104 iterations 3 53  Cbc0038I Pass  31: (10.62 seconds) suminf.   38.57092 (112) obj. 744.104 iterations 1444 54  Cbc0038I Pass  32: (10.67 seconds) suminf.   37.19574 (109) obj. 744.104 iterations 231 55  Cbc0038I Pass  33: (10.70 seconds) suminf.   36.59574 (107) obj. 744.104 iterations 159 56  Cbc0038I Pass  34: (10.71 seconds) suminf.   36.59574 (107) obj. 744.104 iterations 0 57  Cbc0038I Pass  35: (10.74 seconds) suminf.   36.52908 (107) obj. 744.104 iterations 29 58  Cbc0038I Pass  36: (10.77 seconds) suminf.   36.26241 (106) obj. 744.104 iterations 82 59  Cbc0038I Pass  37: (10.80 seconds) suminf.   36.19574 (106) obj. 744.104 iterations 115 60  Cbc0038I Pass  38: (10.83 seconds) suminf.   35.92908 (105) obj. 744.104 iterations 91 61  Cbc0038I Pass  39: (10.86 seconds) suminf.   35.52908 (105) obj. 744.104 iterations 58 62  Cbc0038I Pass  40: (10.89 seconds) suminf.   35.26241 (103) obj. 744.104 iterations 48 63  Cbc0038I Pass  41: (10.91 seconds) suminf.   35.26241 (103) obj. 744.104 iterations 0 64  Cbc0038I Pass  42: (10.94 seconds) suminf.   34.59574 (102) obj. 744.104 iterations 65 65  Cbc0038I Pass  43: (11.00 seconds) suminf.   33.39574 (99) obj. 744.104 iterations 253 66  Cbc0038I Rounding solution of 764 is better than previous of 765 67 68  Cbc0038I Before mini branch and bound, 7332 integers at bound fixed and 30532 continuous 69  Cbc0038I Full problem 37313 rows 42882 columns, reduced to 1758 rows 1877 columns 70  Cbc0038I Mini branch and bound did not improve solution (15.54 seconds) 71  Cbc0038I After 15.54 seconds - Feasibility pump exiting with objective of 742 - took 6.36 seconds 72  Cbc0012I Integer solution of 742 found by feasibility pump after 0 iterations and 0 nodes 73  (15.55 seconds) 74  Cbc0027I Exiting on user event 75  Cbc0005I Partial search - best objective 653 (best possible 629.9), took 3188627 iterations  76  and 1068 nodes (3615.33 seconds) 77  Cbc0032I Strong branching done 16196 times (715305 iterations), fathomed 0 nodes and fixed 0  78  variables 79  Cbc0035I Maximum depth 52, 0 variables fixed on reduced cost 80  Cuts at root node changed objective from 565.042 to 629.9 81  Probing was tried 1274 times and created 211829 cuts of which 4667 were active after adding  82  rounds of cuts (4.965 seconds) 83  Gomory was tried 1274 times and created 9045 cuts of which 0 were active after adding rounds  84  of cuts (32.725 seconds) 85  Knapsack was tried 1274 times and created 233 cuts of which 0 were active after adding rounds  86  of cuts (22.010 seconds) 87  Clique was tried 10 times and created 0 cuts of which 0 were active after adding rounds of cuts  88  (0.012 seconds) 89  MixedIntegerRounding2 was tried 1274 times and created 20769 cuts of which 0 were active after  90  adding rounds of cuts (12.944 seconds) 91  FlowCover was tried 10 times and created 150 cuts of which 0 were active after adding rounds  92  of cuts (0.263 seconds) 93  TwoMirCuts was tried 1274 times and created 50422 cuts of which 0 were active after adding  94  rounds of cuts (11.078 seconds) 95  ZeroHalf was tried 1274 times and created 921 cuts of which 0 were active after adding rounds  96  of cuts (10.462 seconds) 97  ImplicationCuts was tried 20 times and created 634 cuts of which 0 were active after adding  98  rounds of cuts (0.006 seconds) 99 100  Result - User ctrl-cuser ctrl-c 101 102 Objective value:                653.00000000 103 Lower bound:                    629.900 104 Gap:                            0.04 105 Enumerated nodes:               1068 106 Total iterations:               3188627 107 Time (CPU seconds):             3620.45 108 Time (Wallclock seconds):       3620.51 109 110 Total time (CPU seconds):       3620.46   (Wallclock seconds):       3620.52"},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"symphony","dir":"Articles","previous_headings":"Experimental settings","what":"Symphony","title":"Solver benchmarks","text":"Contrary previous logs shown, symphony offers minimalistic yet essential amount information. CBC, set stop criteria 3600 seconds, reasons. noted, sections () (ii) omitted, section (iv) indicates objective value solution achieved (lines 38 44). turn, section (iii) similar log gurobi CPLEX (lines 8 36). Note recent solution uncovered target value 646. currently evaluating whether constitutes optimal solution (reflecting gap 2.49%), pertinent highlight confident asserting optimality based solutions identified gurobi CPLEX.","code":"1  Starting Preprocessing... 2  Preprocessing finished... 3     coefficients modified: 268 4       constraints removed: 48 5       variables fixed: 290 6       variables aggregated: 17 7 8  Solving... 9 10     Time       Done     Queued                  LB                  UB     Gap  11       48          1          1              629.90              652.00    3.39  12       54          8          8              629.90              652.00    3.39  13       60         17         17              629.90              652.00    3.39  14       66         26         26              629.90              652.00    3.39  15       72         36         36              629.90              651.00    3.24  16       78         47         47              629.90              649.00    2.94  17       84         61         61              629.90              648.00    2.79  18       90         76         76              629.90              648.00    2.79  19       96         90         90              629.90              648.00    2.79  20      102        106        106              629.90              648.00    2.79  21    ... 22     3511       4343       4343              629.90              646.00    2.49  23     3517       4348       4348              629.90              646.00    2.49  24     3523       4352       4352              629.90              646.00    2.49  25     3529       4357       4357              629.90              646.00    2.49  26     3535       4362       4362              629.90              646.00    2.49  27     3541       4366       4366              629.90              646.00    2.49  28     3547       4369       4369              629.90              646.00    2.49  29     3553       4373       4373              629.90              646.00    2.49  30     3559       4378       4378              629.90              646.00    2.49  31     3566       4382       4382              629.90              646.00    2.49  32     3572       4386       4386              629.90              646.00    2.49  33     3578       4389       4389              629.90              646.00    2.49  34     3585       4394       4394              629.90              646.00    2.49  35     3592       4398       4398              629.90              646.00    2.49  36     3598       4402       4402              629.90              646.00    2.49  37  38  **************************************************** 39  * Time Limit Reached                               * 40  **************************************************** 41 42 43  Solution Found: Node 217, Level 109 44  Solution Cost: 646.000000000"},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Solver benchmarks","text":"conducted 48 tests, encompassing three distinct models (models (), (B), (C)) spanning four recovery targets (10%, 20%, 30%, 40%). tests carried across four available solvers within prioriactions framework, comprising two academic solvers (gurobi CPLEX) two non-academic alternatives (CBC symphony).","code":""},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"academic-solvers-gurobi-vs-cplex","dir":"Articles","previous_headings":"Results","what":"Academic solvers: gurobi vs CPLEX","title":"Solver benchmarks","text":"Upon comparing two academic solvers, similarity behaviour becomes evident. context gurobi, optimal solutions successfully achieved across scenarios, evidenced gaps amounting zero. Similarly, employing CPLEX, observed zero gaps across scenarios, exceptions occurring model (C) targeting 10%, gap 0.73% emerged, model (C) targeting 30%, exhibited gap 0.24% (see upper right box previous Figure). Nonetheless, consistent disparity becomes apparent terms processing times. gurobi consistently exhibited lead verifying optimal solutions across scenarios, slight variations model () (distanced seconds). Assuming CPLEX achieved optimal solutions instances, verification required average 3510.847 seconds. contrast, gurobi outperformed average 1365.47 seconds, representing approximately 39% time taken CPLEX (see bottom boxes previous Figure).","code":""},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"non-academic-solvers-cbc-vs-symphony","dir":"Articles","previous_headings":"Results","what":"Non-academic solvers: CBC vs symphony","title":"Solver benchmarks","text":"context, varied panorama, CBC notably standing . 8 12 comparative analyses symphony, CBC demonstrated superior solution qualities, indicated upper boxes Figure . Furthermore, average gaps achieved CBC stand 6.35%, counterpart averages 9.06%. Turning run times, CBC exhibited capability verify optimal solutions ahead symphony model (), particularly target restrictions 30% 40%. However, noteworthy solvers encountered challenges validating optimality obtained solutions remaining models (see bottom boxes Figure ).","code":""},{"path":"https://josesalgr.github.io/mosap/articles/benchmark.html","id":"conclusions","dir":"Articles","previous_headings":"","what":"Conclusions","title":"Solver benchmarks","text":"benchmark findings underscore considerable variability time required resolve multi-action management planning challenges. temporal difference contingent upon diverse factors, encompassing problem’s scale, intricacy, solver engaged formulating prioritization. Notably, specific solvers, symphony solver, may demand several hours address predicament resolved within minutes solvers like CPLEX gurobi. terms recommendations, advise prioritizing utilization gurobi CPLEX solvers whenever feasible, frequently exhibit superior performance respect non-academic solvers. academics can avail special licenses solvers cost, crucial recognize conservation planners within governmental non-governmental entities might access resources. scenarios access aforementioned solvers limited, propose adoption CBC solver, generally demonstrates better efficacy compared symphony. case, due complexity exploring detail possible instances (number units, species, threats respective combinations), recommend cautious results. Considering intrinsic combinatorial nature models, even solvers robust gurobi may encounter difficulties tackling exhaustive analyses.","code":""},{"path":"https://josesalgr.github.io/mosap/articles/MitchellRiver.html","id":"preparing-and-analyzing-input-data","dir":"Articles","previous_headings":"","what":"1) Preparing and analyzing input data","title":"Mitchell River","text":"divided whole catchment (71,630 km2km^2) 2316 sites (.e., sub-catchments), one included portion river length two consecutive river connections surrounding land draining river stretch. sourced distribution 45 fish species Mitchell river catchment conservation features [@cattarino2015]. Also, considered four major threats freshwater fish species catchment: water buffalo (Bubalis bubalis), cane toad (Bufo marinus), river flow alteration (caused infrastructure water extractions levee banks) grazing land use . input files loaded directly prioriactions package follows: load shapefile case study also included part package installation:  loading instance’s data, can plot different distributions features threats shapefile loaded. , can assign values tabular input fields shapefile containing distribution native species threats:  Likewise, can plot distributions threats applying following instructions:  solve models, solver configured stop criterion 5% gap (gap_limit = 0.05), means solver end execution finds solution whose gap least 5%, indicating 0% solution optimal. Similarly, stopping criteria time (time_limit), available solve() reference. also option using stopping criteria make solver run finds optimal solution; however, take long time period. Section 2, present results obtained solving base model case study. Likewise, Section 3 report results obtained incorporating different curves benefit calculation. finally, Section 4 present results obtained incorporating connectivity requirements model.","code":"path <- system.file(\"extdata/mitchell_vignette_data/\",                      package = \"prioriactions\")  pu_data <- data.table::fread(file = paste0(path,                                     \"/pu_mitchell.csv\"),                               data.table = FALSE) features_data <- data.table::fread(file = paste0(path,                                           \"/features_mitchell.csv\"),                                     data.table = FALSE) dist_features_data <- data.table::fread(file = paste0(path,                                                \"/dist_features_mitchell.csv\"),                                          data.table = FALSE) threats_data <- data.table::fread(file = paste0(path,                                          \"/threats_mitchell.csv\"),                                    data.table = FALSE) dist_threats_data <- data.table::fread(file = paste0(path,                                               \"/dist_threats_mitchell.csv\"),                                         data.table = FALSE) bound_data <- data.table::fread(file = paste0(path,                                        \"/boundary_mitchell.csv\"),                                  data.table = FALSE) sensitivity_data <- data.table::fread(file = paste0(path,                                              \"/sensibility_mitchell.csv\"),                                        data.table = FALSE) # read shapefile mit_pu = raster::shapefile(\"data/Mitchell.shp\")  # plot sapefile plot(mit_pu) # load amount of dist_features data dist_features <- reshape2::dcast(dist_features_data,                                  pu~feature,                                  value.var = \"amount\",                                  fill = 0)  # assign the distribution of first feature to feature_distribution field  # in the shapefile mit_pu$feature_distribution <- dist_features[, 2]  # plot distribution with tmap library tmap::tm_shape(mit_pu) +   tmap::tm_fill(\"feature_distribution\",                 pal = c(\"white\", \"seagreen\"),                 labels = c(\"0\", \"1\"),                 breaks = c(0,1,2)) +   tmap::tm_borders(col=\"black\",                    lwd = 0.5) # load amount of dist_threats data dist_threats <- reshape2::dcast(dist_threats_data,                                  pu~threat,                                 value.var = \"amount\",                                  fill = 0)  # assign the distribution of third threat to feature_distribution field  # in the shapefile mit_pu$threat_distribution <- dist_threats[, 4]  # plot distribution with tmap library tmap::tm_shape(mit_pu) +   tmap::tm_fill(\"threat_distribution\",                  pal = c(\"white\", \"red4\"),                  labels = c(\"0\", \"1\"),                  breaks = c(0,1,2)) +   tmap::tm_borders(col=\"black\",                     lwd = 0.5)"},{"path":"https://josesalgr.github.io/mosap/articles/MitchellRiver.html","id":"base-model","dir":"Articles","previous_headings":"","what":"2) Base model","title":"Mitchell River","text":"First, base model considers prioritization management actions abate particular threat using previously loaded data. Note features threats presence/absence values (binary values). characteristics base model following: use minimiCosts type model minimize costs reaching 15% maximum recovery benefit per feature target. model consider spatial requirements (blm blm_actions parameters equal 0). need solving threats impacting particular species given planning unit achieve secure persistence species planning unit (.e., curve parameter equal 1). proceed follow three-step scheme described prioriactions package: 1) data validation, 2) model creation 3) model optimization. Now, order set recovery targets 20%, must know maximum recovery benefit possible getPotentialBenefit() function. assign new target (20% maximum) corresponding column feature data input create object Data-class . input data validated, proceed create mathematical model using problem() function curve = 1. Note dimension model 37371 mathematical constraints 43180 variables. using getModelInfo() function, can display additional information model: solve corresponding model, solver set considering 5% optimality gap stopping criterion (note 0% gap means problem solved optimality) using gurobi solver. turn, verbose = TRUE used display execution solver output_file = FALSE avoid generating output files results. achieved gap 4.57% objective value 1333 time 2.88 seconds. relevant information can obtained getPerformance() function: Since objective function contain connectivity component (blm blm_actions set zero), objective value corresponds sum actions monitoring costs. can check using getCost() function: shows actions highest total cost correspond go threat 4, corresponding monitoring. use getActions() function get distribution conservation actions. Note set recovery targets use recovery target planning propose, planning units selected prescribing management actions threats, planning units selected conservation. planning units selected connectivity blm blm_actions set zero. way plot distributions species threats, can also explore spatial distribution management actions included optimal solution:  Also, can show distribution sum actions (higher density actions):  use results base model comparisons following planning exercises.","code":"# step 1: data validation input_data <- inputData(pu = pu_data,                features = features_data,                dist_features = dist_features_data,               threats = threats_data,                dist_threats = dist_threats_data,                sensitivity = sensitivity_data,               bound = bound_data)  input_data ## Data ##   planning units: data.frame (2316 units) ##   monitoring costs:     min: 1, max: 1 ##   features:       scl_ja, nem_er, thr_sc, ... (45 features) ##   threats:        threat1, threat2, threat3, threat4 (4 threats) ##   action costs:   min: 1, max: 1 # view the maximum benefit to achieve maximum_benefits <- getPotentialBenefit(input_data)  head(maximum_benefits) ##   feature dist dist_threatened maximum.conservation.benefit maximum.recovery.benefit maximum.benefit ## 1       1  692             692                            0                      692             692 ## 2       2 1052            1052                            0                     1052            1052 ## 3       3  416             416                            0                      416             416 ## 4       4  653             653                            0                      653             653 ## 5       5  238             238                            0                      238             238 ## 6       6  276             276                            0                      276             276 features_data$target_recovery <- maximum_benefits$maximum.recovery.benefit * 0.2  # step 1: validate modified data input_data <- inputData(pu = pu_data,                          features = features_data,                          dist_features = dist_features_data,                         threats = threats_data,                          dist_threats = dist_threats_data,                          sensitivity = sensitivity_data,                         bound = bound_data)  input_data ## Data ##   planning units: data.frame (2316 units) ##   monitoring costs:     min: 1, max: 1 ##   features:       scl_ja, nem_er, thr_sc, ... (45 features) ##   threats:        threat1, threat2, threat3, threat4 (4 threats) ##   action costs:   min: 1, max: 1 # step 2: model.base <- problem(input_data,                        model_type = \"minimizeCosts\",                        blm = 0) ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases model.base ## Optimization Problem ##   model sense: minimization ##   dimensions:  37371, 43180, 1813.016 kB (nrow, ncol, size) ##   variables:   43180 getModelInfo(model.base) ##    model_sense n_constraints n_variables        size ## 1 minimization         37371       43180 1813.016 kB # step 3: solution.base <- solve(model.base,                         gap_limit = 0.05,                         verbose = TRUE,                         output_file = FALSE,                        cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 37371 rows, 43180 columns and 136566 nonzeros ## Model fingerprint: 0xc61c114a ## Variable types: 34965 continuous, 8215 integer (8215 binary) ## Coefficient statistics: ##   Matrix range     [3e-01, 4e+00] ##   Objective range  [1e+00, 1e+00] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 4e+02] ## Found heuristic solution: objective 7947.0000000 ## Found heuristic solution: objective 6638.0000000 ## Presolve removed 35017 rows and 35259 columns ## Presolve time: 0.25s ## Presolved: 2354 rows, 7921 columns, 66284 nonzeros ## Variable types: 0 continuous, 7921 integer (7904 binary) ##  ## Root relaxation: objective 1.145583e+03, 4158 iterations, 0.09 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 1145.58333    0  547 6638.00000 1145.58333  82.7%     -    0s ## H    0     0                    1396.0000000 1145.58333  17.9%     -    0s ## H    0     0                    1393.0000000 1145.58333  17.8%     -    0s ##      0     0 1173.77778    0  712 1393.00000 1173.77778  15.7%     -    0s ## H    0     0                    1369.0000000 1173.77778  14.3%     -    0s ##      0     0 1175.01235    0  696 1369.00000 1175.01235  14.2%     -    1s ##      0     0 1175.12963    0  691 1369.00000 1175.12963  14.2%     -    1s ##      0     0 1222.36111    0  479 1369.00000 1222.36111  10.7%     -    1s ## H    0     0                    1333.0000000 1222.36111  8.30%     -    1s ##      0     0 1225.44444    0  469 1333.00000 1225.44444  8.07%     -    1s ##      0     0 1225.44444    0  472 1333.00000 1225.44444  8.07%     -    1s ##      0     0 1241.19444    0  305 1333.00000 1241.19444  6.89%     -    1s ##      0     0 1242.75000    0  292 1333.00000 1242.75000  6.77%     -    1s ##      0     0 1242.75000    0  291 1333.00000 1242.75000  6.77%     -    1s ##      0     0 1271.33333    0   68 1333.00000 1271.33333  4.63%     -    1s ##  ## Cutting planes: ##   Gomory: 1 ##   Cover: 1214 ##   Clique: 11 ##   MIR: 482 ##   StrongCG: 1 ##   RLT: 2 ##  ## Explored 1 nodes (14581 simplex iterations) in 1.58 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 6: 1333 1369 1393 ... 7947 ##  ## Optimal solution found (tolerance 5.00e-02) ## Best objective 1.333000000000e+03, best bound 1.272000000000e+03, gap 4.5761% getPerformance(solution.base) ##   solution_name objective_value   gap solving_time                                              status ## 1           sol            1333 4.576         1.58 Optimal solution (according to gap tolerance: 0.05) getCost(solution.base) ##   solution_name monitoring threat_1 threat_2 threat_3 threat_4 ## 1           sol        486        0      395        0      452 # get actions distribution solution_actions.base <- getActions(solution.base)  head(solution_actions.base) ##   solution_name pu 1 2 3 4 conservation connectivity ## 1           sol  1 0 0 0 0            0            0 ## 2           sol  2 0 0 0 0            0            0 ## 3           sol  3 0 1 0 1            0            0 ## 4           sol  4 0 0 0 0            0            0 ## 5           sol  5 0 0 0 0            0            0 ## 6           sol  6 0 1 0 1            0            0 # assign solution to shapefile field to plot it mit_pu$action_1.base <-  solution_actions.base$`1` mit_pu$action_2.base <-  solution_actions.base$`2` mit_pu$action_3.base <-  solution_actions.base$`3` mit_pu$action_4.base <-  solution_actions.base$`4`  # actions plots plot_action1.base <- tmap::tm_shape(mit_pu) +                       tmap::tm_fill(\"action_1.base\",                                     pal = c(\"white\", \"dodgerblue4\"),                                     labels = c(\"0\", \"1\"),                                     breaks = c(0,1,2)) +                       tmap::tm_borders(col=\"black\",                                        lwd = 0.5)  plot_action2.base <- tmap::tm_shape(mit_pu) +                       tmap::tm_fill(\"action_2.base\",                                     pal = c(\"white\", \"dodgerblue4\"),                                     labels = c(\"0\", \"1\"),                                     breaks = c(0,1,2)) +                       tmap::tm_borders(col=\"black\",                                        lwd = 0.5)  plot_action3.base <- tmap::tm_shape(mit_pu) +                       tmap::tm_fill(\"action_3.base\",                                     pal = c(\"white\", \"dodgerblue4\"),                                     labels = c(\"0\", \"1\"),                                     breaks = c(0,1,2)) +                       tmap::tm_borders(col=\"black\",                                        lwd = 0.5)  plot_action4.base <- tmap::tm_shape(mit_pu) +                       tmap::tm_fill(\"action_4.base\",                                     pal = c(\"white\", \"dodgerblue4\"),                                     labels = c(\"0\", \"1\"),                                     breaks = c(0,1,2)) +                       tmap::tm_borders(col=\"black\",                                        lwd = 0.5)  tmap::tmap_arrange(plot_action1.base,                     plot_action2.base,                     plot_action3.base,                     plot_action4.base) mit_pu$sum_actions.base <- solution_actions.base$`1` +                                   solution_actions.base$`2` +                                   solution_actions.base$`3` +                                   solution_actions.base$`4` +                                  solution_actions.base$connectivity*5  # plot sum of actions with tmap library plot.base <- tmap::tm_shape(mit_pu) +               tmap::tm_fill(\"sum_actions.base\",                             palette=\"viridis\",                             labels = c(\"do nothing\",                                        \"one action\",                                        \"two actions\",                                        \"three actions\",                                        \"four actions\",                                        \"connectivity\"),                             breaks = c(0,1,2,3,4,5,6)) +                tmap::tm_borders(col=\"black\",                                 lwd = 0.5)  plot.base"},{"path":"https://josesalgr.github.io/mosap/articles/MitchellRiver.html","id":"model-with-different-curve-param","dir":"Articles","previous_headings":"","what":"3) Model with different curve param","title":"Mitchell River","text":"model differs previous one tries group conservation actions within selected sites part management plan (non-linear relationship calculation benefits). desirable threats impacting given species needed abated ensure long-term persistence (e.g., species highly sensitive threats planning unit). latter done adding value 1 curve parameter. : (1) indicates linear relationship ratio actions carried respect possible actions carried respect benefit obtained characteristic actions considered equally important, species specially sensitive . (2) indicates quadratic relationship values, (3) cubic relationship. number segments refers number smaller portions curve divided linealize . Larger values segments result complex models. Note new model associates larger instance (43180 78145 variables) compared previously presented model. consequence, resulting problem computationally difficult. solution resulting model objective function value equal 1336 (greater previous one), although corresponding optimality gap 4.79% (similar one attained simple model). complete output solver shown : Note last solution reached 177326 seconds. specifically demonstrates complexity increases using different parameters curves.  , display representations solution obtained , base curve models. can seen maps greater number sites larger concentration management actions compared previous model (example, greater number units green).","code":"model.curve <- prioriactions::problem(input_data,                                       model_type = \"minimizeCosts\",                                       blm = 0,                                        curve = 3,                                       segments = 5) ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases model.curve ## Optimization Problem ##   model sense: minimization ##   dimensions:  37371, 78145, 1952.872 kB (nrow, ncol, size) ##   variables:   78145 solution.curve <- prioriactions::solve(model.curve,                                         gap_limit = 0.05,                                         verbose = TRUE,                                         output_file = FALSE,                                        cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 37371 rows, 78145 columns and 136566 nonzeros ## Model fingerprint: 0x727af3a5 ## Model has 34965 general constraints ## Variable types: 69930 continuous, 8215 integer (8215 binary) ## Coefficient statistics: ##   Matrix range     [3e-01, 4e+00] ##   Objective range  [1e+00, 1e+00] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 4e+02] ## Found heuristic solution: objective 8215.0000000 ## Presolve added 69869 rows and 174524 columns ## Presolve time: 0.78s ## Presolved: 107240 rows, 252669 columns, 695592 nonzeros ## Presolved model has 34965 SOS constraint(s) ## Found heuristic solution: objective 7947.0000000 ## Variable types: 244742 continuous, 7927 integer (7911 binary) ##  ## Deterministic concurrent LP optimizer: primal and dual simplex ## Showing first log only... ##  ##  ## Root simplex log... ##  ## Iteration    Objective       Primal Inf.    Dual Inf.      Time ##    52139    2.7269611e+03   0.000000e+00   1.876868e+04      5s ##    77100    2.2476995e+03   0.000000e+00   1.868763e+04     10s ##    93792    2.0070600e+03   0.000000e+00   1.542965e+04     15s ## Concurrent spin time: 0.01s ##  ## Solved with dual simplex ##  ## Root relaxation: objective 1.144050e+03, 54270 iterations, 14.95 seconds ## Total elapsed time = 21.11s ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 1144.05000    0 6203 7947.00000 1144.05000  85.6%     -   22s ## H    0     0                    7924.0000000 1144.05000  85.6%     -   23s ##      0     0 1148.84167    0 8970 7924.00000 1148.84167  85.5%     -   28s ## H    0     0                    2094.0000000 1148.84167  45.1%     -   32s ##      0     0 1162.52272    0 11530 2094.00000 1162.52272  44.5%     -   37s ##      0     0 1187.87778    0 6309 2094.00000 1187.87778  43.3%     -   43s ##      0     0 1201.60000    0 5121 2094.00000 1201.60000  42.6%     -   46s ##      0     0 1201.60000    0 5072 2094.00000 1201.60000  42.6%     -   46s ##      0     0 1205.21667    0 5214 2094.00000 1205.21667  42.4%     -   51s ##      0     0 1221.05556    0 5864 2094.00000 1221.05556  41.7%     -   54s ##      0     0 1245.76667    0 3135 2094.00000 1245.76667  40.5%     -   59s ##      0     0 1247.26667    0 2809 2094.00000 1247.26667  40.4%     -   61s ##      0     0 1247.26667    0 3125 2094.00000 1247.26667  40.4%     -   63s ##      0     0 1269.26667    0 3240 2094.00000 1269.26667  39.4%     -   69s ## H    0     0                    1472.0000000 1269.26667  13.8%     -   79s ##      0     0 1269.26667    0 2501 1472.00000 1269.26667  13.8%     -   81s ##      0     0 1269.92292    0 2699 1472.00000 1269.92292  13.7%     -   86s ##      0     0 1270.83333    0 1876 1472.00000 1270.83333  13.7%     -   88s ##      0     0 1270.83333    0 1741 1472.00000 1270.83333  13.7%     -   88s ##      0     0 1272.00000    0 2068 1472.00000 1272.00000  13.6%     -   92s ## H    0     0                    1371.0000000 1272.00000  7.22%     -  103s ##      0     0 1272.00000    0 1726 1371.00000 1272.00000  7.22%     -  105s ##      0     0 1272.00000    0 2194 1371.00000 1272.00000  7.22%     -  109s ##      0     0 1272.00000    0 1548 1371.00000 1272.00000  7.22%     -  123s ## H    0     0                    1353.0000000 1272.00000  5.99%     -  141s ## H    0     0                    1348.0000000 1272.00000  5.64%     -  151s ##      0     2 1272.00000    0 1537 1348.00000 1272.00000  5.64%     -  154s ##      1     4 1272.00000    1 1672 1348.00000 1272.00000  5.64%  4286  156s ##      5     8 1272.00000    2 1772 1348.00000 1272.00000  5.64%  2175  163s ##      7    10 1272.00000    3 1883 1348.00000 1272.00000  5.64%  2229  165s ##     17    26 1272.00000    5 1793 1348.00000 1272.00000  5.64%  1052  171s ##     25    42 1272.00000    9 1689 1348.00000 1272.00000  5.64%   769  183s ## H   27    42                    1344.0000000 1272.00000  5.36%   725  183s ##     41    86 1272.00000   16 1691 1344.00000 1272.00000  5.36%   494  207s ## H   62    86                    1341.0000000 1272.00000  5.15%   371  207s ## H   84    86                    1340.0000000 1272.00000  5.07%   298  207s ##     85   178 1272.00000   34 1689 1340.00000 1272.00000  5.07%   295  233s ## H  108   178                    1339.0000000 1272.00000  5.00%   245  233s ## H  111   178                    1338.0000000 1272.00000  4.93%   239  233s ##  ## Cutting planes: ##   Cover: 1439 ##   Implied bound: 29488 ##   Clique: 144 ##   MIR: 426 ##   Flow cover: 3219 ##   Network: 4 ##   RLT: 2 ##   Relax-and-lift: 12413 ##  ## Explored 177 nodes (219985 simplex iterations) in 233.32 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 10: 1338 1339 1340 ... 2094 ##  ## Optimal solution found (tolerance 5.00e-02) ## Warning: max constraint violation (1.3502e-02) exceeds tolerance ## Warning: max general constraint violation (1.3502e-02) exceeds tolerance ##          (model may be infeasible or unbounded - try turning presolve off) ## Best objective 1.338000000000e+03, best bound 1.272000000000e+03, gap 4.9327% # get action distribution solution_actions.curve <- prioriactions::getActions(solution.curve)  # assign solution to shapefile field to plot it mit_pu$action_1.curve <- solution_actions.curve$`1` mit_pu$action_2.curve <- solution_actions.curve$`2` mit_pu$action_3.curve <- solution_actions.curve$`3` mit_pu$action_4.curve <- solution_actions.curve$`4`  mit_pu$sum_actions.curve <- solution_actions.curve$`1` +                                    solution_actions.curve$`2` +                                    solution_actions.curve$`3` +                                    solution_actions.curve$`4` +                                   solution_actions.curve$connectivity*5  # plot sum of actions with tmap library plot.curve <- tmap::tm_shape(mit_pu) +                tmap::tm_fill(\"sum_actions.curve\",                              palette=\"viridis\",                              labels = c(\"do nothing\",                                         \"one action\",                                         \"two actions\",                                         \"three actions\",                                         \"four actions\",                                        \"connectivity\"),                              breaks = c(0,1,2,3,4,5,6)) +                tmap::tm_borders(col=\"black\",                                 lwd = 0.5)  # comparative with base model solution tmap::tmap_arrange(plot.base, plot.curve)"},{"path":"https://josesalgr.github.io/mosap/articles/MitchellRiver.html","id":"model-with-connectivity-requirements","dir":"Articles","previous_headings":"","what":"4) Model with connectivity requirements","title":"Mitchell River","text":"add connectivity requirements model, two key parameters: blm (equivalent parameter blm used marxan), tries minimize connectivity penalty selected planning units (.e. regardless conservation actions carried within ). following explore solutions change adding connectivity requirements. way occurs previous model, addition spatial requirements leads higher costs requirement implies higher costs management plan, well model greater computational complexity. obtain costs solutions (base connectivity requirements) use getCost() function:  can seen displayed maps, including connectivity penalty objective function allows find compact solution compared one obtained base model. Besides optimizing spatial connectivity selected units, package also allows optimize spatial connectivity among units given action applied. penalty encoded factor blm_actions, aims ensuring spatial coherence among units action applied. spatial clumping actions might beneficial economic terms (economy scales) even ecological terms (higher effectiveness management plans, creating larger areas threat-free reducing probability reappearance threat). impact including penalty (blm_actions) shown summarize distribution different actions:   can see case, inclusion connectivity requirements actions , therefore, attempt minimize connectivity penalty , produced different solution previous one. Actions selected along river network concentrating greater extent source mouth river. addition, observed planning unit painted yellow (connectivity), due fact selected units least one management action , opposite previous case. Note blm blm_actions values used set exaggerated way clearly verify behavior models.","code":"input_data.conn <- inputData(pu = pu_data,                               features = features_data,                               dist_features = dist_features_data,                              threats = threats_data,                               dist_threats = dist_threats_data,                                                 sensitivity = sensitivity_data,                              bound = bound_data)  model.conn <- problem(input_data.conn,                       model_type = \"minimizeCosts\",                       blm = 5,                        curve = 1) ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases solution.conn <- solve(model.conn,                         gap_limit = 0.05,                         verbose = TRUE,                         output_file = FALSE,                        cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 78567 rows, 56912 columns and 232690 nonzeros ## Model fingerprint: 0x5fa5d86a ## Variable types: 34965 continuous, 21947 integer (21947 binary) ## Coefficient statistics: ##   Matrix range     [3e-01, 4e+00] ##   Objective range  [1e+00, 6e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 4e+02] ## Found heuristic solution: objective 7947.0000000 ## Presolve removed 35010 rows and 35250 columns ## Presolve time: 0.44s ## Presolved: 43557 rows, 21662 columns, 162430 nonzeros ## Variable types: 0 continuous, 21662 integer (21646 binary) ##  ## Deterministic concurrent LP optimizer: primal and dual simplex ## Showing first log only... ##  ##  ## Root simplex log... ##  ## Iteration    Objective       Primal Inf.    Dual Inf.      Time ##    34261    1.6462609e+03   0.000000e+00   1.224723e+04      5s ## Concurrent spin time: 0.00s ##  ## Solved with dual simplex ##  ## Root relaxation: objective 1.246656e+03, 17330 iterations, 8.14 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 1246.65555    0 14894 7947.00000 1246.65555  84.3%     -   10s ## H    0     0                    3698.1750000 1246.65555  66.3%     -   10s ## H    0     0                    3596.0050000 1246.65555  65.3%     -   10s ##      0     0 1309.93713    0 16243 3596.00500 1309.93713  63.6%     -   24s ##      0     0 1439.10567    0 10246 3596.00500 1439.10567  60.0%     -   33s ## H    0     0                    3516.8050000 1439.10567  59.1%     -   33s ##      0     0 1445.28767    0 10627 3516.80500 1445.28767  58.9%     -   37s ##      0     0 1448.58070    0 10616 3516.80500 1448.58070  58.8%     -   37s ##      0     0 1451.95708    0 10273 3516.80500 1451.95708  58.7%     -   38s ##      0     0 1453.67899    0 10278 3516.80500 1453.67899  58.7%     -   41s ## H    0     0                    3395.0450000 1453.67899  57.2%     -   41s ##      0     0 1455.14266    0 10282 3395.04500 1455.14266  57.1%     -   41s ##      0     0 1455.14286    0 10280 3395.04500 1455.14286  57.1%     -   41s ##      0     0 1456.20718    0 10336 3395.04500 1456.20718  57.1%     -   45s ##      0     0 1459.99389    0 10267 3395.04500 1459.99389  57.0%     -   48s ## H    0     0                    3309.2750000 1459.99389  55.9%     -   49s ##      0     0 1459.99389    0 10268 3309.27500 1459.99389  55.9%     -   49s ##      0     0 1461.98299    0 10272 3309.27500 1461.98299  55.8%     -   49s ##      0     0 1462.38513    0 10269 3309.27500 1462.38513  55.8%     -   50s ## H    0     0                    3228.9150000 1462.38513  54.7%     -   50s ##      0     0 1462.54676    0 10270 3228.91500 1462.54676  54.7%     -   51s ##      0     0 1463.90458    0 10278 3228.91500 1463.90458  54.7%     -   52s ## H    0     0                    3202.0750000 1463.90458  54.3%     -   52s ##      0     0 1463.90499    0 10278 3202.07500 1463.90499  54.3%     -   52s ##      0     0 1463.95170    0 10271 3202.07500 1463.95170  54.3%     -   53s ## H    0     0                    3159.7400000 1463.95170  53.7%     -   53s ##      0     0 1463.95444    0 10269 3159.74000 1463.95444  53.7%     -   53s ##      0     0 1463.95444    0 10259 3159.74000 1463.95444  53.7%     -   59s ## H    0     0                    2681.2700000 1463.98668  45.4%     -   63s ## H    0     0                    2669.5000000 1463.98668  45.2%     -   64s ## H    0     2                    2663.2400000 1463.98668  45.0%     -   64s ##      0     2 1463.98668    0 10258 2663.24000 1463.98668  45.0%     -   64s ##      1     4 1479.00207    1 10266 2663.24000 1463.98668  45.0%  2422   67s ##      3     6 1485.05504    2 10506 2663.24000 1470.82439  44.8%  2547   72s ##      5     8 1497.89727    2 11879 2663.24000 1470.89149  44.8%  3705   78s ##      7    10 1489.66829    3 9823 2663.24000 1477.28291  44.5%  3020   80s ##     11    14 1500.40849    4 9901 2663.24000 1489.69722  44.1%  2744   86s ##     13    16 1525.41094    4 9311 2663.24000 1492.54486  44.0%  3116   92s ##     17    21 1538.21142    5 9950 2663.24000 1495.32210  43.9%  3237   96s ##     24    27 1532.40163    7 8478 2663.24000 1495.32210  43.9%  2899  102s ## H   26    32                    2641.8200000 1495.32210  43.4%  2778  105s ## H   29    32                    1620.4800000 1495.32210  7.72%  2617  105s ##     33    40 1545.13627    9 9169 1620.48000 1495.32210  7.72%  2574  110s ##     43    50 1554.53682   13 7430 1620.48000 1495.32210  7.72%  2249  117s ##     55    61 1609.51801   19 5050 1620.48000 1495.32210  7.72%  2170  122s ## H   56    61                    1615.4100000 1495.32210  7.43%  2132  122s ## H   57    61                    1604.9900000 1495.32210  6.83%  2126  122s ##     66    73 1579.91224   21 6348 1604.99000 1495.32210  6.83%  1957  126s ##     82    82 1590.35993   26 5939 1604.99000 1495.32210  6.83%  1742  131s ## H   88    91                    1602.9900000 1495.32210  6.72%  1761  133s ##     97    96     cutoff   28      1602.99000 1495.36416  6.71%  1609  136s ##    114    99 1531.50176    4 5624 1602.99000 1495.36416  6.71%  1583  141s ##    122   110 1535.54610    6 5703 1602.99000 1495.36416  6.71%  1589  150s ##    153   136 1543.17555    9 3290 1602.99000 1495.36416  6.71%  1468  157s ## H  171   112                    1589.1600000 1495.36416  5.90%  1338  160s ##    184   116 1548.70522   12 2616 1589.16000 1495.36416  5.90%  1291  166s ##    198   116 1572.42119   17 2476 1589.16000 1495.36416  5.90%  1361  175s ## H  199   116                    1588.1600000 1495.36416  5.84%  1354  175s ##    210   124 1579.00047   23 2452 1588.16000 1498.01688  5.68%  1418  184s ##    226   127 1518.05974    4 6270 1588.16000 1498.01688  5.68%  1426  189s ##    241   136 1526.96262    6 5569 1588.16000 1498.01688  5.68%  1400  194s ##    250   141 1542.67287    8 3703 1588.16000 1498.01688  5.68%  1436  198s ##    255   147 1555.54545   10 3384 1588.16000 1498.01688  5.68%  1469  205s ##    261   157 1563.94638   13 2923 1588.16000 1498.01688  5.68%  1491  210s ##    273   169 1582.15750   19  569 1588.16000 1498.01688  5.68%  1487  215s ## H  285   161                    1583.4950000 1498.01688  5.40%  1429  215s ##    298   150     cutoff   32      1583.49500 1504.40589  4.99%  1404  243s ## H  306   140                    1582.4950000 1504.42814  4.93%  1392  243s ##  ## Cutting planes: ##   Gomory: 2 ##   Cover: 1 ##   MIR: 1 ##   Zero half: 10 ##   Mod-K: 1 ##   RLT: 92 ##  ## Explored 307 nodes (487058 simplex iterations) in 243.79 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 10: 1582.5 1583.5 1588.16 ... 2663.24 ##  ## Optimal solution found (tolerance 5.00e-02) ## Best objective 1.582495000000e+03, best bound 1.504430000000e+03, gap 4.9330% getCost(solution.base) ##   solution_name monitoring threat_1 threat_2 threat_3 threat_4 ## 1           sol        486        0      395        0      452 getCost(solution.conn) ##   solution_name monitoring threat_1 threat_2 threat_3 threat_4 ## 1           sol        512        4      383       24      478 # get action distribution solution_actions.conn<- getActions(solution.conn)  # assign solution to shapefile field to plot it mit_pu$action_1.conn <- solution_actions.conn$`1` mit_pu$action_2.conn <- solution_actions.conn$`2` mit_pu$action_3.conn <- solution_actions.conn$`3` mit_pu$action_4.conn <- solution_actions.conn$`4`  mit_pu$sum_actions.conn <- solution_actions.conn$`1` +                                   solution_actions.conn$`2` +                                   solution_actions.conn$`3` +                                   solution_actions.conn$`4` +                                  solution_actions.conn$connectivity*5  # plot sum of actions with tmap library plot.conn <- tmap::tm_shape(mit_pu) +               tmap::tm_fill(\"sum_actions.conn\",                             palette=\"viridis\",                             labels = c(\"do nothing\",                                        \"one action\",                                        \"two actions\",                                        \"three actions\",                                        \"four actions\",                                        \"connectivity\"),                             breaks = c(0,1,2,3,4,5,6)) +               tmap::tm_borders(col=\"black\", lwd = 0.5)  # comparative with base model solution tmap::tmap_arrange(plot.base, plot.conn) threats_data$blm_actions <- 10  input_data.conn_actions<- inputData(pu = pu_data,                                      features = features_data,                                      dist_features = dist_features_data,                                     threats = threats_data,                                      dist_threats = dist_threats_data,                                                                                      sensitivity = sensitivity_data,                                     bound = bound_data)  model.conn_actions <- problem(input_data.conn_actions,                                model_type = \"minimizeCosts\",                               blm = 0,                                curve = 1) ## Warning: The blm argument was set to 0, so the boundary data has no effect solution.conn_actions <- solve(model.conn_actions,                                 gap_limit = 0.05,                                 verbose = TRUE,                                 output_file = FALSE,                                cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 141237 rows, 77802 columns and 378920 nonzeros ## Model fingerprint: 0x885bc8c7 ## Variable types: 34965 continuous, 42837 integer (42837 binary) ## Coefficient statistics: ##   Matrix range     [3e-01, 4e+00] ##   Objective range  [1e+00, 1e+02] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 4e+02] ## Found heuristic solution: objective 8210.0000000 ## Presolve removed 35014 rows and 34975 columns ## Presolve time: 0.96s ## Presolved: 106223 rows, 42827 columns, 308960 nonzeros ## Variable types: 0 continuous, 42827 integer (42826 binary) ##  ## Deterministic concurrent LP optimizer: primal and dual simplex ## Showing first log only... ##  ## Warning: Markowitz tolerance tightened to 0.5 ##  ## Root simplex log... ##  ## Iteration    Objective       Primal Inf.    Dual Inf.      Time ##    54062    1.6758547e+04   0.000000e+00   3.523879e+05      5s ##    59110    1.4264445e+04   0.000000e+00   2.019730e+06     10s ##    64902    1.1453028e+04   0.000000e+00   7.894121e+05     15s ## Concurrent spin time: 0.00s ##  ## Solved with dual simplex ##  ## Root relaxation: objective 1.387112e+03, 12682 iterations, 16.66 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0 1387.11192    0 15106 8210.00000 1387.11192  83.1%     -   22s ## H    0     0                    2930.1300000 1387.11192  52.7%     -   22s ## H    0     0                    2816.8600000 1387.11192  50.8%     -   22s ##      0     0 1497.64057    0 25226 2816.86000 1497.64057  46.8%     -   57s ##      0     0 1602.83358    0 22616 2816.86000 1602.83358  43.1%     -   87s ##      0     0 1629.59690    0 23347 2816.86000 1629.59690  42.1%     -  104s ##      0     0 1629.62176    0 23347 2816.86000 1629.62176  42.1%     -  105s ##      0     0 1629.62176    0 23349 2816.86000 1629.62176  42.1%     -  139s ##      0     0 1642.01139    0 22540 2816.86000 1642.01139  41.7%     -  144s ##      0     0 1643.38223    0 23350 2816.86000 1643.38223  41.7%     -  144s ##      0     0 1664.68953    0 20463 2816.86000 1664.68953  40.9%     -  150s ##      0     0 1666.68340    0 20477 2816.86000 1666.68340  40.8%     -  153s ## H    0     0                    2556.0800000 1666.68340  34.8%     -  153s ##      0     0 1666.68340    0 20477 2556.08000 1666.68340  34.8%     -  154s ##      0     0 1666.68340    0 20477 2556.08000 1666.68340  34.8%     -  157s ##      0     0 1666.68340    0 20477 2556.08000 1666.68340  34.8%     -  159s ##      0     0 1666.68340    0 20477 2556.08000 1666.68340  34.8%     -  161s ##      0     0 1666.68340    0 20477 2556.08000 1666.68340  34.8%     -  163s ##      0     0 1666.68340    0 20477 2556.08000 1666.68340  34.8%     -  175s ## H    0     0                    2361.1600000 1666.68340  29.4%     -  181s ## H    0     0                    2097.7200000 1666.72070  20.5%     -  195s ##      0     2 1666.72070    0 20477 2097.72000 1666.72070  20.5%     -  196s ##      3     6 1715.75083    2 20386 2097.72000 1677.19380  20.0%  1240  203s ##      5     8 1692.26282    2 13548 2097.72000 1692.26282  19.3%  1175  206s ##      9    12 1782.34551    4 7349 2097.72000 1692.27111  19.3%  1083  211s ##     13    16 1792.86198    5 15495 2097.72000 1692.27111  19.3%  1055  215s ##     17    21 1811.72923    6 7176 2097.72000 1692.27111  19.3%   977  221s ##     25    30 1849.43709   10 5992 2097.72000 1692.27111  19.3%   854  227s ##     29    33 1924.53917   12 4683 2097.72000 1692.27111  19.3%   844  231s ##     34    39 1926.12316   13 2864 2097.72000 1692.27111  19.3%   818  235s ##     48    54 1969.45762   19 2604 2097.72000 1692.27111  19.3%   716  243s ##     53    56 1997.25743   22 1961 2097.72000 1692.27111  19.3%   732  245s ##     69    84 2028.65056   28 1020 2097.72000 1692.27111  19.3%   691  250s ## H   86    98                    2054.2200000 1692.27111  17.6%   596  251s ##    112    94 1722.88360    4 18041 2054.22000 1715.78538  16.5%   502  257s ##    114    96 1731.39051    5 19458 2054.22000 1715.78538  16.5%   510  262s ##    116    98 1760.04039    6 18070 2054.22000 1715.78538  16.5%   533  266s ## H  120   102                    2053.2200000 1715.78538  16.4%   542  271s ##    124   106 1854.93650    8 16198 2053.22000 1715.78538  16.4%   559  277s ##    128   112 1893.15612    9 7120 2053.22000 1715.78538  16.4%   573  283s ##    132   115 1904.84053   10 6441 2053.22000 1715.78538  16.4%   590  286s ##    135   116 1942.18466   11 13828 2053.22000 1715.78538  16.4%   599  290s ##    143   120 1976.64116   13 5546 2053.22000 1715.78538  16.4%   605  298s ##    147   123 2008.69048   15 5092 2053.22000 1715.78538  16.4%   616  301s ##    162   127 2040.30944   21 8430 2053.22000 1715.78538  16.4%   591  308s ##    170   125     cutoff   24      2053.22000 1722.89852  16.1%   583  313s ##    179   128 1848.87803    4 16419 2053.22000 1722.89852  16.1%   579  316s ##    182   132 1903.19904    5 16409 2053.22000 1722.89852  16.1%   585  320s ##    186   137 1930.89000    6 12783 2053.22000 1722.89852  16.1%   590  326s ##    191   144 2016.77456    8 14455 2053.22000 1722.89852  16.1%   599  332s ##    198   142     cutoff   10      2053.22000 1722.89852  16.1%   596  336s ##    208   142     cutoff   11      2053.22000 1722.89852  16.1%   589  342s ## H  210   108                    1955.8600000 1722.89852  11.9%   584  342s ##    212   107     cutoff    9      1955.86000 1722.89852  11.9%   589  346s ##    217   109     cutoff    7      1955.86000 1722.89852  11.9%   591  351s ##    221   108     cutoff    8      1955.86000 1741.07771  11.0%   595  355s ##    226   111 1869.85317    7 5571 1955.86000 1741.07771  11.0%   599  360s ##    233   112 1915.79755   10 6748 1955.86000 1741.07771  11.0%   598  365s ##    242   108     cutoff   15      1955.86000 1741.09877  11.0%   597  370s ##    246   109 1798.56988    4 23201 1955.86000 1741.09877  11.0%   604  379s ##    252   107 1836.72651    6 23535 1955.86000 1741.09877  11.0%   614  390s ##    257   111 1840.77630    7 23289 1955.86000 1741.09877  11.0%   612  396s ##    261   112 1886.17922    9 21572 1955.86000 1741.09877  11.0%   618  401s ##    264   114 1917.28761   11 18382 1955.86000 1741.09877  11.0%   625  408s ##    268   112 1950.88683   13 22722 1955.86000 1741.09877  11.0%   634  416s ##    273   103     cutoff   14      1955.86000 1741.09877  11.0%   640  424s ##    279   105     cutoff   13      1955.86000 1742.34798  10.9%   644  431s ##    287   110 1798.64451    6 16895 1955.86000 1743.07059  10.9%   643  439s ##    292   114 1849.97755    9 16451 1955.86000 1743.07059  10.9%   647  447s ##    296   114 1905.28056   12 19863 1955.86000 1743.07059  10.9%   659  454s ##    300   114 1951.49899   14 21190 1955.86000 1743.07059  10.9%   665  466s ##    302   114     cutoff   15      1955.86000 1743.07059  10.9%   666  474s ##    310   116     cutoff   14      1955.86000 1746.39579  10.7%   665  483s ##    316   116 1924.19322    6 17963 1955.86000 1746.39579  10.7%   678  490s ##    324   120 1955.63488    8 16868 1955.86000 1747.34019  10.7%   677  499s ##    336   124 1827.53308    6 18787 1955.86000 1747.34019  10.7%   674  507s ##    340   126 1874.75743    8 18972 1955.86000 1747.34019  10.7%   679  515s ##    352   132 1911.71416   12 17434 1955.86000 1747.34019  10.7%   674  526s ##    362   134     cutoff   14      1955.86000 1760.04355  10.0%   680  536s ##    380   140 1861.38350    7 22553 1955.86000 1760.05177  10.0%   675  546s ##    386   146 1926.94598   10 21717 1955.86000 1760.05177  10.0%   681  558s ##    392   143     cutoff   13      1955.86000 1765.26924  9.74%   688  568s ##    401   146 1824.79435    8 18323 1955.86000 1765.26924  9.74%   693  581s ## H  406   143                    1945.0800000 1765.26924  9.24%   692  581s ##    408   149 1890.66415   11 17915 1945.08000 1765.26924  9.24%   697  592s ##    418   157     cutoff   14      1945.08000 1768.78005  9.06%   701  604s ##    442   167 1876.71440    9 17448 1945.08000 1768.78005  9.06%   691  617s ##    466   171 1941.47117   11 13810 1945.08000 1772.57410  8.87%   680  632s ##    490   180 1867.06379    8 19807 1945.08000 1772.57410  8.87%   672  646s ##    507   181 1934.92361   12 21389 1945.08000 1772.57410  8.87%   672  662s ##    514   180     cutoff   12      1945.08000 1778.29638  8.57%   677  675s ##    525   183 1932.15804    7 16272 1945.08000 1778.29638  8.57%   685  693s ##    550   190 1924.29967    9 16817 1945.08000 1779.55964  8.51%   681  710s ##    573   187 1931.03225    8 13196 1945.08000 1779.55964  8.51%   679  725s ##    592   196     cutoff    7      1945.08000 1785.31926  8.21%   677  741s ##    607   198     cutoff   13      1945.08000 1787.55603  8.10%   682  762s ##    625   204 1895.91317   11 15343 1945.08000 1788.63906  8.04%   681  778s ##    647   205     cutoff    8      1945.08000 1788.63906  8.04%   680  798s ##    664   212 1929.65162   10 20394 1945.08000 1796.41834  7.64%   683  817s ##    683   209 1931.90876   11 7852 1945.08000 1796.41834  7.64%   686  840s ##    698   207 1935.81662   13 16737 1945.08000 1798.92171  7.51%   687  869s ##    724   208 1927.13341   10 15588 1945.08000 1800.04610  7.46%   688  890s ##    753   225 1869.45083   13 6983 1945.08000 1800.04610  7.46%   684  910s ##    788   241 1943.88355   32 11904 1945.08000 1800.52986  7.43%   679  932s ##    833   245 1934.28613   16 14407 1945.08000 1806.08808  7.15%   672  961s ##    861   245 1940.71495   11 18743 1945.08000 1810.07917  6.94%   668  987s ##    903   248 1919.31247    8 6785 1945.08000 1813.78912  6.75%   666 1014s ##    934   255 1912.39802    9 9715 1945.08000 1816.14882  6.63%   671 1040s ##    977   257     cutoff   14      1945.08000 1818.65888  6.50%   670 1106s ##    983   255     cutoff   14      1945.08000 1819.30717  6.47%   670 1139s ##   1009   259     cutoff   10      1945.08000 1823.30903  6.26%   675 1167s ##   1055   269 1888.89817    9 17104 1945.08000 1825.01021  6.17%   670 1197s ##   1137   278     cutoff   15      1945.08000 1825.11358  6.17%   653 1228s ##   1198   291 1882.44430    7 14385 1945.08000 1828.59922  5.99%   648 1261s ##   1235   296     cutoff   13      1945.08000 1829.84581  5.92%   649 1295s ##   1308   305 1929.04687    9 15021 1945.08000 1832.07625  5.81%   645 1329s ##   1363   305 1920.03769   12 4560 1945.08000 1835.44347  5.64%   644 1364s ##   1411   306     cutoff   12      1945.08000 1837.33710  5.54%   646 1403s ##   1443   322 1909.20286   15 6422 1945.08000 1837.46242  5.53%   650 1444s ##   1534   320 1921.00778   12 14362 1945.08000 1841.27962  5.34%   639 1485s ##   1592   321     cutoff   14      1945.08000 1845.32342  5.13%   641 1529s ##  ## Cutting planes: ##   Zero half: 3 ##   RLT: 54 ##   BQP: 3 ##  ## Explored 1677 nodes (1111591 simplex iterations) in 1529.26 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 10: 1945.08 1955.86 2053.22 ... 8210 ##  ## Optimal solution found (tolerance 5.00e-02) ## Best objective 1.945080000000e+03, best bound 1.849470000000e+03, gap 4.9155% # get action distribution solution_actions.conn_actions <- getActions(solution.conn_actions)  # assign solution to shapefile field to plot it mit_pu$action_1.conn_actions <- solution_actions.conn_actions$`1` mit_pu$action_2.conn_actions <- solution_actions.conn_actions$`2` mit_pu$action_3.conn_actions <- solution_actions.conn_actions$`3` mit_pu$action_4.conn_actions <- solution_actions.conn_actions$`4`  # actions plots plot_action1.conn_actions<- tmap::tm_shape(mit_pu) +                              tmap::tm_fill(\"action_1.conn_actions\",                                            pal = c(\"white\", \"dodgerblue4\"),                                            labels = c(\"0\", \"1\"),                                            breaks = c(0,1,2)) +                              tmap::tm_borders(col=\"black\", lwd = 0.5)  plot_action2.conn_actions <- tmap::tm_shape(mit_pu) +                               tmap::tm_fill(\"action_2.conn_actions\",                                             pal = c(\"white\", \"dodgerblue4\"),                                             labels = c(\"0\", \"1\"),                                             breaks = c(0,1,2)) +                               tmap::tm_borders(col=\"black\", lwd = 0.5)  plot_action3.conn_actions <- tmap::tm_shape(mit_pu) +                               tmap::tm_fill(\"action_3.conn_actions\",                                             pal = c(\"white\", \"dodgerblue4\"),                                             labels = c(\"0\", \"1\"),                                             breaks = c(0,1,2)) +                               tmap::tm_borders(col=\"black\", lwd = 0.5)  plot_action4.conn_actions <- tmap::tm_shape(mit_pu) +                               tmap::tm_fill(\"action_4.conn_actions\",                                             pal = c(\"white\", \"dodgerblue4\"),                                             labels = c(\"0\", \"1\"),                                             breaks = c(0,1,2)) +                               tmap::tm_borders(col=\"black\", lwd = 0.5)  tmap::tmap_arrange(plot_action1.conn_actions,                     plot_action2.conn_actions,                     plot_action3.conn_actions,                     plot_action4.conn_actions) # get action distribution mit_pu$sum_actions.conn_actions <- solution_actions.conn_actions$`1` +                                               solution_actions.conn_actions$`2` +                                               solution_actions.conn_actions$`3` +                                               solution_actions.conn_actions$`4` +                                     solution_actions.conn_actions$connectivity*5  # plot sum of actions with tmap library plot.conn_actions <- tmap::tm_shape(mit_pu) +               tmap::tm_fill(\"sum_actions.conn_actions\",                             palette=\"viridis\",                             labels = c(\"do nothing\",                                        \"one action\",                                        \"two actions\",                                        \"three actions\",                                        \"four actions\",                                        \"connectivity\"),                             breaks = c(0,1,2,3,4,5,6)) +               tmap::tm_borders(col=\"black\", lwd = 0.5)  # comparative with base model solution tmap::tmap_arrange(plot.base, plot.conn_actions)"},{"path":"https://josesalgr.github.io/mosap/articles/MitchellRiver.html","id":"conclusions","dir":"Articles","previous_headings":"","what":"5) Conclusions","title":"Mitchell River","text":"previously resolved models show capabilities prioriactions package. vignette, specifically explore can obtain 20% representativeness species modifying different input parameters. base case, assumed spatial requirement solutions; implies less complex model later ones. next measure incorporated cubic relationship benefit calculation (parameter curve = 3)(see benefit calculate sensitivities vignette), reduced solutions higher expensive actions densities. last two models assumed connectivity requirements solutions (blm blm_actions parameters), increase costs compared base case. Note stopping criterion models obtaining minimum gap (gap_limit parameter). However, solutions obtained gaps important differences, , far 0% (optimal solution), implies comparison different solutions done carefully generalize. obtain lower gaps, suggested use longer resolution time.","code":""},{"path":"https://josesalgr.github.io/mosap/articles/objectives.html","id":"model-i-only-recovery-targets","dir":"Articles","previous_headings":"","what":"1) Model I: Only recovery targets","title":"Planning objectives","text":"order analyze planning decision behave conservation target considered, present results using example available Get started vignette. explained package description, can use getPotentialBenefit() function know maximum benefit can achieved types planning objectives: can observe, features 2 3 present 2 10 units, respectively, threat present. Therefore, select units just monitoring, contribute achieving conservation target. order show impact including recovery requirements, now present results obtained setting value target_recovery 10. setting values, solve corresponding model. steps shown . corresponding optimization problem solved, can retrieve spatial distribution recovery actions using getActions() function. results obtained test instance shown :","code":"# load package library(prioriactions)  data(sim_boundary_data, sim_dist_features_data, sim_dist_threats_data,      sim_features_data, sim_pu_data, sim_sensitivity_data, sim_threats_data)  #create raster library(raster)  r <- raster(ncol=10, nrow=10, xmn=0, xmx=10, ymn=0, ymx=10) values(r) <- 0  # create data class using input data from prioriactions b <- inputData(pu = sim_pu_data,                 features = sim_features_data,                 dist_features = sim_dist_features_data,                 threats = sim_threats_data,                 dist_threats = sim_dist_threats_data,                 sensitivity = sim_sensitivity_data,                 boundary = sim_boundary_data)  # print problem print(b) # get potential benefit getPotentialBenefit(b) ##   feature dist dist_threatened maximum.conservation.benefit maximum.recovery.benefit maximum.benefit ## 1       1   47              47                            0                       47              47 ## 2       2   30              28                            2                       28              30 ## 3       3   66              56                           10                       56              66 ## 4       4   33              33                            0                       33              33 # setting the targets features_data.base <- sim_features_data features_data.base$target_recovery <- 10  # create conservation problem using data from prioriactions b.base <- inputData(pu = sim_pu_data,                 features = features_data.base,                 dist_features = sim_dist_features_data,                 threats = sim_threats_data,                 dist_threats = sim_dist_threats_data,                 sensitivity = sim_sensitivity_data,                 boundary = sim_boundary_data)  # create optimization problem c.base <- problem(b.base, model_type = \"minimizeCosts\") ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases # solve optimization problem d.base <- solve(c.base, solver = \"gurobi\", verbose = TRUE, output_file = FALSE, cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0xe4778898 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+01, 1e+01] ## Found heuristic solution: objective 964.0000000 ## Found heuristic solution: objective 371.0000000 ## Presolve removed 250 rows and 277 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 119 columns, 237 nonzeros ## Variable types: 0 continuous, 119 integer (101 binary) ##  ## Root relaxation: objective 1.310000e+02, 30 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0  131.00000    0    6  371.00000  131.00000  64.7%     -    0s ## H    0     0                     143.0000000  131.00000  8.39%     -    0s ## H    0     0                     142.0000000  131.00000  7.75%     -    0s ##      0     0  134.00000    0    4  142.00000  134.00000  5.63%     -    0s ## H    0     0                     138.0000000  134.00000  2.90%     -    0s ## H    0     0                     134.0000000  134.00000  0.00%     -    0s ##      0     0  134.00000    0    4  134.00000  134.00000  0.00%     -    0s ##  ## Cutting planes: ##   Gomory: 1 ##   Cover: 5 ##  ## Explored 1 nodes (39 simplex iterations) in 0.00 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 6: 134 138 142 ... 964 ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 1.340000000000e+02, best bound 1.340000000000e+02, gap 0.0000% # get actions from solution actions.base <- getActions(d.base, format = \"wide\")  # plot actions group_rasters <- raster::stack(r, r) values(group_rasters[[1]]) <- actions.base$`1` values(group_rasters[[2]]) <- actions.base$`2` names(group_rasters) <- c(\"action 1\", \"action 2\")  plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/objectives.html","id":"model-ii-recovery-and-conservation-targets","dir":"Articles","previous_headings":"","what":"2) Model II: Recovery and conservation targets","title":"Planning objectives","text":"section, present results obtained considering conservation targets. Note value targets bounded maximum possible benefits can obtained according structure planning area. corresponding value maximum possible benefits can retrieved using getPotentialBenefit() function. already seen previous section, values correspond 0, 2, 10 0 respectively.conservation targets values defined, corresponding optimization model solved. steps shown . can seen log, objective function value attained solution 157. value 23 units larger value obtained instance without imposing conservation targets (values 134). difference explained fact now impose implementation monitoring actions.  can observe , case, units selected conservation overlap selected applying action 1 action 2. comparing solution one shown model , observe cases spatial distribution recovery actions .","code":"# setting the targets features_data.cons <- sim_features_data features_data.cons$target_recovery <- 10 features_data.cons$target_conservation <- c(0, 2, 10, 0)  # create conservation problem using data from prioriactions b.cons <- inputData(pu = sim_pu_data,                 features = features_data.cons,                 dist_features = sim_dist_features_data,                 threats = sim_threats_data,                 dist_threats = sim_dist_threats_data,                 sensitivity = sim_sensitivity_data,                 boundary = sim_boundary_data)  # create optimization problem c.cons <- problem(b.cons, model_type = \"minimizeCosts\") ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases # solve optimization problem d.cons <- solve(c.cons, solver = \"gurobi\", verbose = TRUE, output_file = FALSE, cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0xf6bb92ed ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [2e+00, 1e+01] ## Found heuristic solution: objective 964.0000000 ## Found heuristic solution: objective 381.0000000 ## Presolve removed 250 rows and 277 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 119 columns, 237 nonzeros ## Variable types: 0 continuous, 119 integer (101 binary) ##  ## Root relaxation: objective 1.540000e+02, 30 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0  154.00000    0    6  381.00000  154.00000  59.6%     -    0s ## H    0     0                     166.0000000  154.00000  7.23%     -    0s ## H    0     0                     165.0000000  154.00000  6.67%     -    0s ##      0     0  157.00000    0    4  165.00000  157.00000  4.85%     -    0s ## H    0     0                     161.0000000  157.00000  2.48%     -    0s ## H    0     0                     157.0000000  157.00000  0.00%     -    0s ##      0     0  157.00000    0    4  157.00000  157.00000  0.00%     -    0s ##  ## Cutting planes: ##   Gomory: 1 ##   Cover: 5 ##  ## Explored 1 nodes (39 simplex iterations) in 0.01 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 6: 157 161 165 ... 964 ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 1.570000000000e+02, best bound 1.570000000000e+02, gap 0.0000% # get actions from solution actions.cons <- getActions(d.cons, format = \"wide\")  # plot actions group_rasters <- raster::stack(r, r, r) values(group_rasters[[1]]) <- actions.cons$`1` values(group_rasters[[2]]) <- actions.cons$`2` values(group_rasters[[3]]) <- actions.cons$`conservation` names(group_rasters) <- c(\"action 1\", \"action 2\", \"conservation\")  plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/objectives.html","id":"model-iii-only-recovery-targets-and-connectivity","dir":"Articles","previous_headings":"","what":"3) Model III: Only recovery targets and connectivity","title":"Planning objectives","text":"demonstrate influence including connectivity constrains use inputs , set connectivity penalty factor (blm) 100 problem() function. Next modify parameter model uses recovery targets.  can notice selected actions connected compared solutions shown previous models.","code":"# create optimization problem c.base_conn <- problem(b.base,                    model_type = \"minimizeCosts\",                   blm = 100) ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases # solve optimization problem d.base_conn <- solve(c.base_conn, solver = \"gurobi\", verbose = TRUE, output_file = FALSE, cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 29984 rows, 10296 columns and 70085 nonzeros ## Model fingerprint: 0x0d6e31a0 ## Variable types: 176 continuous, 10120 integer (10120 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 7e+04] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 1e+01] ## Found heuristic solution: objective 964.0000000 ## Presolve removed 190 rows and 181 columns ## Presolve time: 0.22s ## Presolved: 29794 rows, 10115 columns, 69709 nonzeros ## Variable types: 0 continuous, 10115 integer (10110 binary) ##  ## Root relaxation: objective 2.573214e+02, 253 iterations, 0.09 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ## *    0     0               0     547.0000000  547.00000  0.00%     -    0s ##  ## Explored 0 nodes (306 simplex iterations) in 0.43 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 2: 547 964  ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 5.470000000163e+02, best bound 5.469999999816e+02, gap 0.0000% # get actions from solution actions.base_conn <- getActions(d.base_conn, format = \"wide\")  # plot actions group_rasters <- raster::stack(r, r) values(group_rasters[[1]]) <- actions.base_conn$`1` values(group_rasters[[2]]) <- actions.base_conn$`2` names(group_rasters) <- c(\"action 1\", \"action 2\")  plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/objectives.html","id":"model-iv-recovery-and-conservation-targets-and-connectivity","dir":"Articles","previous_headings":"","what":"4) Model IV: Recovery and conservation targets and connectivity","title":"Planning objectives","text":", set blm parameter 100, now using conservation targets.  Note last two models (incorporate connectivity requirements) solutions differ. used parameters, inferred sites selected conservation species affect certain way selection units recovery targets, important carefully think planning objectives, might lead different solutions.","code":"# create optimization problem c.cons_conn <- problem(b.cons,                         model_type = \"minimizeCosts\",                        blm = 100) ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases # solve optimization problem d.cons_conn <- solve(c.cons_conn, solver = \"gurobi\", verbose = TRUE, output_file = FALSE, cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 29984 rows, 10296 columns and 70085 nonzeros ## Model fingerprint: 0x8ba6f640 ## Variable types: 176 continuous, 10120 integer (10120 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 7e+04] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [1e+00, 1e+01] ## Found heuristic solution: objective 964.0000000 ## Presolve removed 5860 rows and 2081 columns ## Presolve time: 0.21s ## Presolved: 24124 rows, 8215 columns, 56479 nonzeros ## Variable types: 0 continuous, 8215 integer (8210 binary) ##  ## Root relaxation: objective 5.470000e+02, 9 iterations, 0.01 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ## *    0     0               0     547.0000000  547.00000  0.00%     -    0s ##  ## Explored 0 nodes (9 simplex iterations) in 0.28 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 2: 547 964  ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 5.470000000163e+02, best bound 5.469999999524e+02, gap 0.0000% # get actions from solution actions.cons_conn <- getActions(d.cons_conn, format = \"wide\")  # plot actions group_rasters <- raster::stack(r, r, r) values(group_rasters[[1]]) <- actions.cons_conn$`1` values(group_rasters[[2]]) <- actions.cons_conn$`2` values(group_rasters[[3]]) <- actions.cons_conn$`conservation` names(group_rasters) <- c(\"action 1\", \"action 2\", \"conservation\")  plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Introduction to prioriactions","text":"prioriactions package characterized using two main types functions: creation solve functions mathematical models (three-steps logic); functions obtain information objects created (e.g. getActions()). first group functions comprised three clear steps: Input data validation, using inputData() function. function returns data-class object contains information input data. Create mathematical model, using problem() function. function returns optimizationProblem-class object contains information related mathematical model created. Solve model, using solve() function. function returns solution-class object contains information related solution.  three steps can summarized using single function: prioriactions() function. allows input data validation, creation mathematical model resolution single step, returning solution-class object contains information related solution. recommend three step scheme due allows us verify steps correct, can helpful check errors without completely rerunning everything . example, note optimizationProblem-class object can take significant time create (depending large inputs ). therefore, stepwise scheme allows us generate optimizationProblem-class object (following first two steps) experiment different parameters solving solve() function.","code":""},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"workflow","dir":"Articles","previous_headings":"","what":"Workflow","title":"Introduction to prioriactions","text":"general workflow working prioriactions : Call inputData() function verify inputs correct structure. Call problem() function create mathematical model. series parameters allow control different aspects model. Call solve() function solve model created previous step. Get information solutions get prefix functions (e.g. getActions() getSolutionBenefit()).","code":""},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Introduction to prioriactions","text":"introduce use prioriactions package presenting inputs data style obtaining results. First, load prioriactions package. package inherits input data marxan software, widely known conservation planning (details marxan user manual). data contains information species/features case study spatial information . , case study divided multiple sites called planning units (PU). turn, information provided representativeness values (targets) obtained species/feature. filds cost associated PU. package follows data format incorporates information threats relationship species/features. inputs package tabular format (.e. data.frame). information mandatory fields input data, please see help page inputData() function. can find basic example using prioriactions.","code":"# load package library(prioriactions)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"planning-units-data","dir":"Articles","previous_headings":"Usage","what":"Planning units data","title":"Introduction to prioriactions","text":"data.frame contains information PU ids, monitoring costs, status. Monitoring cost reflects cost monitoring planning unit either selected recovery (e.g., monitoring presence threats intensity) conservation (e.g., monitoring ensure threats present ,therefore, conservation might needed). Status indicates PU must (locked ) part solution . example contains 100 planning units, monitoring cost values ranging 1 10 status 0 (locked). RasterLayerobject can used present spatial information. , planning units represented raster (.e. RasterLayer object) pixel corresponds spatial extent panning unit. , pixel values correspond monitoring costs planning unit.","code":"# load planning unit data from prioriactions data(sim_pu_data)  # print first six rows of data head(sim_pu_data) ##   id monitoring_cost status ## 1  1               2      0 ## 2  2               2      0 ## 3  3               2      0 ## 4  4               2      0 ## 5  5               2      0 ## 6  6               2      0 #plot monitoring costs library(raster)   r <- raster(ncol=10, nrow=10, xmn=0, xmx=10, ymn=0, ymx=10) values(r) <- sim_pu_data$monitoring_cost plot(r)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"features-data","dir":"Articles","previous_headings":"Usage","what":"Features data","title":"Introduction to prioriactions","text":"two input data related features; first one data.frame contains information features id targets (mandatory minimizing costs). second data.frame contains information spatial distribution features across planning units. mentioned , information can either binary (presence-absence) continuous (e.g., probability occurrence feature planning unit, area occupancy features planning unit). way planning units, RasterLayerobject can used present spatial information. pixel values layer correspond amount suitable feature available given planning unit. Note planning unit raster layer conservation feature stack exactly spatial properties (.e. resolution, extent, coordinate reference system) pixels line perfectly. example, assume binary values amount (presence absence features).","code":"# load features data from prioriactions data(sim_features_data, sim_dist_features_data)  # print first six rows of data head(sim_features_data) ##   id target_recovery     name ## 1  1              11 feature1 ## 2  2              16 feature2 ## 3  3               8 feature3 ## 4  4               9 feature4 head(sim_dist_features_data) ##     pu feature amount ## 201  1       3      1 ## 202  2       3      1 ## 203  3       3      1 ## 204  4       3      1 ## 205  5       3      1 ## 206  6       3      1 # load amount of features data features <- reshape2::dcast(sim_dist_features_data,                              pu~feature,                             value.var = \"amount\",                              fill = 0)  # create stack layer group_rasters <- raster::stack(r, r, r, r) values(group_rasters[[1]]) <- features$`1` values(group_rasters[[2]]) <- features$`2` values(group_rasters[[3]]) <- features$`3` values(group_rasters[[4]]) <- features$`4`  names(group_rasters) <- c(\"feature 1\", \"feature 2\", \"feature 3\", \"feature 4\") plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"threats-data","dir":"Articles","previous_headings":"Usage","what":"Threats data","title":"Introduction to prioriactions","text":"three input data related threats. first one provides information threats id name. second provides information spatial distribution threats last one indicates features sensitive threat (sensitivities data). Note sim_dist_threats_data file contains information cost implementing action threat site, addition status given action planning works way status associated PU’s. example, binary amount threats (presence/absence) assumed. However, amount can continuous, implies -depth analysis consequences features (see details sensitivities vignette).","code":"# load threats data from prioriactions data(sim_threats_data, sim_dist_threats_data, sim_sensitivity_data)  # print first six rows of data head(sim_threats_data) ##   id    name blm_actions ## 1  1 threat1           0 ## 2  2 threat2           0 head(sim_dist_threats_data) ##     pu threat amount action_cost status ## 108  8      2      1           2      0 ## 109  9      2      1           2      0 ## 110 10      2      1           2      0 ## 11  11      1      1           3      0 ## 111 11      2      1           4      0 ## 12  12      1      1           3      0 head(sim_sensitivity_data) ##   feature threat ## 1       1      1 ## 2       2      1 ## 3       3      1 ## 4       4      1 ## 5       1      2 ## 6       2      2 # load amount of threat data threats <- reshape2::dcast(sim_dist_threats_data,                             pu~threat,                            value.var = \"amount\",                             fill = 0) threats <- tidyr::complete(threats, pu = 1:100)  # create stack layer group_rasters <- raster::stack(r, r) values(group_rasters[[1]]) <- threats$`1` values(group_rasters[[2]]) <- threats$`2`  names(group_rasters) <- c(\"threat 1\", \"threat 2\") plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"boundary-data","dir":"Articles","previous_headings":"Usage","what":"Boundary data","title":"Introduction to prioriactions","text":"Provides information spatial relationship PU presented long format. input mandatory necessary interested addressing connectivity.","code":"# load boundary data from prioriactions data(sim_boundary_data)  # print first six rows of data head(sim_boundary_data) ##   id1 id2 boundary ## 1   1   1        0 ## 2   2   1        1 ## 3   3   1        2 ## 4   4   1        3 ## 5   5   1        4 ## 6   6   1        5"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"step-1-initialize-the-problem","dir":"Articles","previous_headings":"Usage","what":"Step 1: Initialize the problem","title":"Introduction to prioriactions","text":"loaded data, now create data object inputData() function. can check fields different inputs correct. Note problem created, can obtain information object thus know data loaded correctly. , can use functions inside object (e.g getThreatsAmount()). two methods can use get quick information data. others can found along data-class information. Furthermore, advisable determine maximum benefit achievable conservation feature getPotentialBenefit() function. Since process can carried creation mathematical model, can help establish recovery conservation targets objective mathematical model minimize costs. Note total distribution features (dist) threatened distribution (dist_threatened) reported. Also, report amount features co-occur threats sensitive (maximum.recovery.benefit) co-occur threats sensitive (maximum.conservation.benefit). inclusion last units solutions depend target_conservation field input feature data.","code":"# create conservation problem b <- inputData(pu = sim_pu_data,                 features = sim_features_data,                 dist_features = sim_dist_features_data,                 threats = sim_threats_data,                 dist_threats = sim_dist_threats_data,                 sensitivity = sim_sensitivity_data,                 boundary = sim_boundary_data)  # print problem print(b) ## Data ##   planning units: data.frame (100 units) ##   monitoring costs:     min: 1, max: 10 ##   features:       feature1, feature2, feature3, feature4 (4 features) ##   threats:        threat1, threat2 (2 threats) ##   action costs:   min: 1, max: 10 # get information about object b$getThreatsAmount() ## [1] 2 b$getPlanningUnitsAmount() ## [1] 100 # get benefit information getPotentialBenefit(b) ##   feature dist dist_threatened maximum.conservation.benefit maximum.recovery.benefit maximum.benefit ## 1       1   47              47                            0                       47              47 ## 2       2   30              28                            2                       28              30 ## 3       3   66              56                           10                       56              66 ## 4       4   33              33                            0                       33              33"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"step-2-create-the-mathematical-model","dir":"Articles","previous_headings":"Usage","what":"Step 2: Create the mathematical model","title":"Introduction to prioriactions","text":"next step create optimization problem object data. prioriactions allows types models: minimizeCosts maximizeBenefits. first one, minimizes cost solution whilst ensuring targets met. Instead, second maximizes benefits achieved features subject certain budget. use one set type_model parameter problem() function. Internally, problem() function presolve identifies problems prevents continuing next steps. case target set given species higher maximum achievable, value internally replaced maximum achievable. two warnings indicate values blm blm_actions (arguments achieve greater connectivity solution), therefore input boundary file effect.","code":"# create optimization problem c <- problem(b, model_type = \"minimizeCosts\") ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases # print problem print(c) ## Optimization Problem ##   model sense: minimization ##   dimensions:  284, 396, 12.632 kB (nrow, ncol, size) ##   variables:   396"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"step-3-solve-the-model","dir":"Articles","previous_headings":"Usage","what":"Step 3: Solve the model","title":"Introduction to prioriactions","text":"Finally, creating mathematical model, can now solve solve() function. solve model, need optimizer. Currently, prioriactions available two: gurobi (needs license work) rsymphony (free use). highly recommend using gurobi (information obtain academic license ). Note log shown default relevant information optimization process (verbose = TRUE). information can important evaluating process carried . example, check solution’s quality (gaps), size problem, cores used. information read log MIP_logging documentation. three steps can shortened just one prioriactions() function. function inherits parameters inputData(), problem(), solve() functions:","code":"# solve optimization problem d <- solve(c, solver = \"gurobi\", verbose = TRUE, output_file = FALSE, cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0xc6718513 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [8e+00, 2e+01] ## Found heuristic solution: objective 964.0000000 ## Found heuristic solution: objective 396.0000000 ## Presolve removed 250 rows and 277 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 119 columns, 237 nonzeros ## Variable types: 0 continuous, 119 integer (101 binary) ##  ## Root relaxation: objective 1.445000e+02, 22 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0  144.50000    0    2  396.00000  144.50000  63.5%     -    0s ## H    0     0                     149.0000000  144.50000  3.02%     -    0s ## *    0     0               0     146.0000000  146.00000  0.00%     -    0s ##  ## Cutting planes: ##   Cover: 2 ##  ## Explored 1 nodes (26 simplex iterations) in 0.00 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 4: 146 149 396 964  ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 1.460000000000e+02, best bound 1.460000000000e+02, gap 0.0000% # use prioriactions function d2 <- prioriactions(pu = sim_pu_data, features = sim_features_data,                     dist_features = sim_dist_features_data,                     threats = sim_threats_data,                     dist_threats = sim_dist_threats_data,                     sensitivity = sim_sensitivity_data,                     boundary = sim_boundary_data,                     model_type = \"minimizeCosts\",                      solver = \"gurobi\",                      verbose = TRUE,                      output_file = FALSE,                     cores = 2) ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0xc6718513 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [8e+00, 2e+01] ## Found heuristic solution: objective 964.0000000 ## Found heuristic solution: objective 396.0000000 ## Presolve removed 250 rows and 277 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 119 columns, 237 nonzeros ## Variable types: 0 continuous, 119 integer (101 binary) ##  ## Root relaxation: objective 1.445000e+02, 22 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0  144.50000    0    2  396.00000  144.50000  63.5%     -    0s ## H    0     0                     149.0000000  144.50000  3.02%     -    0s ## *    0     0               0     146.0000000  146.00000  0.00%     -    0s ##  ## Cutting planes: ##   Cover: 2 ##  ## Explored 1 nodes (26 simplex iterations) in 0.00 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 4: 146 149 396 964  ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 1.460000000000e+02, best bound 1.460000000000e+02, gap 0.0000%"},{"path":[]},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"getactions","dir":"Articles","previous_headings":"Getting information about solutions","what":"getActions()","title":"Introduction to prioriactions","text":"function retrieves distribution actions threat across planning units, set planning units selected conservation case mix recovery conservation targets set, group planning units selected connectivity. cases selection particular planning unit either objectives indicated value 1. Note planning unit selected example implementation different actions, multiple 1s found single planning unit. Note getActions() function automatically assumes index action corresponds threat id (since action per threat), case, 1 2 respectively.","code":"# get actions from solution actions <- getActions(d, format = \"wide\")  # print first six rows of data head(actions) ##   solution_name pu 1 2 conservation connectivity ## 1           sol  1 0 0            0            0 ## 2           sol  2 0 0            0            0 ## 3           sol  3 0 0            0            0 ## 4           sol  4 0 0            0            0 ## 5           sol  5 0 0            0            0 ## 6           sol  6 0 0            0            0 # plot actions values(group_rasters[[1]]) <- actions$`1` values(group_rasters[[2]]) <- actions$`2` names(group_rasters) <- c(\"action 1\", \"action 2\")  plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"getsolutionbenefit","dir":"Articles","previous_headings":"Getting information about solutions","what":"getSolutionBenefit()","title":"Introduction to prioriactions","text":"function retrieves benefits achieved feature. output contains information benefit achieved conservation (benefit.conservation), benefit achieved recovery (benefit.recovery) sum (benefit.total). specific case, can seen obtained recovery benefits (actions abate threats) conservation sites. specifically due fact set conservation target. compare benefits obtained concerning established recovery targets, see feature 3, got benefits set target (8). commonly achieved incidental representation, specific actions necessary achieve objective feature end benefiting features. getSolutionBenefit() function also allows obtain benefits achieved planning unit using type param:","code":"# get benefits of solution benefits <- getSolutionBenefit(d, type = \"total\")  # print first six rows of benefit data head(benefits) ##   solution_name feature benefit.conservation benefit.recovery benefit.total ## 1           sol       1                    0               11            11 ## 2           sol       2                    0               16            16 ## 3           sol       3                    0               10            10 ## 4           sol       4                    0                9             9 # get benefits of solution local_benefits <- getSolutionBenefit(d, type = \"local\")  # plot local benefits local_benefits <- reshape2::dcast(local_benefits,                                    pu~feature,                                   value.var = \"benefit.total\",                                    fill = 0)  group_rasters <- raster::stack(r, r, r, r) values(group_rasters[[1]]) <- local_benefits$`1` values(group_rasters[[2]]) <- local_benefits$`2` values(group_rasters[[3]]) <- local_benefits$`3` values(group_rasters[[4]]) <- local_benefits$`4`  names(group_rasters) <- c(\"feature 1\", \"feature 2\", \"feature 3\", \"feature 4\") plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"getcost","dir":"Articles","previous_headings":"Getting information about solutions","what":"getCost()","title":"Introduction to prioriactions","text":"Function obtain costs actions prescribed planning unit, including monitoring actions.","code":"# get costs of solution costs <- getCost(d)  # print the costs data head(costs) ##   solution_name monitoring threat_1 threat_2 ## 1           sol         61       20       65"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"getconnectivitypenalty","dir":"Articles","previous_headings":"Getting information about solutions","what":"getConnectivityPenalty()","title":"Introduction to prioriactions","text":"Function connectivity penalty solution, split overall connectivity penalty among planning units selected part solution (regardless action prescribed), connectivity penalties action individually (e.g., considering subset planning units particular action prescribed). Note cases connectivity penalty shows degree disaggregation planning units solutions, high penalty values indicate solutions poorly connected.","code":"# get connectivity penalty of solution conn <- getConnectivityPenalty(d)  # print the connectivity penalty data head(conn) ##   solution_name    units threat_1 threat_2 ## 1           sol 9042.102  917.544   4095.1"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"getperformance","dir":"Articles","previous_headings":"Getting information about solutions","what":"getPerformance()","title":"Introduction to prioriactions","text":"Function obtain information solving process mathematical model. Four parameters solution presented: objective value depend type model used (minimizeCosts maximizeBenefits); gap, indicates quality solution; solving time status, indicates status solution (whether optimal ). details functions references section.","code":"# get performance of solution perf <- getPerformance(d)  # print the performance data head(perf) ##   solution_name objective_value gap solving_time                                           status ## 1           sol             146   0        0.004 Optimal solution (according to gap tolerance: 0)"},{"path":"https://josesalgr.github.io/mosap/articles/prioriactions.html","id":"sensitivity-analyses-on-blm-budget-and-target-parameters","dir":"Articles","previous_headings":"","what":"Sensitivity analyses on blm, budget and target parameters","title":"Introduction to prioriactions","text":"may interested evaluating different values targets budgets. implemented evaluation functions allow different parameters run sequence mathematical model. can manually running previous steps different parameters (.e., running previous steps parameter, different targets, budgets blm values). However, eval functions two advantages: 1) efficient creating models. model needs build updated new information; 2) output portfolio object, allows obtaining information group solutions, including, get functions related solution objects simultaneously. Now, want evaluate different levels targets. example, 20%, 30% 40% maximum benefit per feature. , use evalTarget() function: Like prioriactions() function, eval functions inherit parameters inputData(), problem(), solve() functions. Note increasing target per feature naturally increases number actions taken achieve therefore associated cost. , turn, increases connectivity values conservation actions.","code":"# evaluate differents targets port <- evalTarget(pu = sim_pu_data, features = sim_features_data,                    dist_features = sim_dist_features_data,                    threats = sim_threats_data,                    dist_threats = sim_dist_threats_data,                    sensitivity = sim_sensitivity_data,                    boundary = sim_boundary_data,                    values = c(0.2, 0.3, 0.4),                     output_file = FALSE) ## ********************************* ##  Iteration 1 of 3: Prop0.2 ## ********************************* ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0x61c57d26 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [4e-01, 1e+01] ## Found heuristic solution: objective 964.0000000 ## Found heuristic solution: objective 311.0000000 ## Presolve removed 250 rows and 277 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 119 columns, 237 nonzeros ## Found heuristic solution: objective 169.0000000 ## Variable types: 0 continuous, 119 integer (101 binary) ##  ## Root relaxation: objective 1.155000e+02, 30 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0  115.50000    0    6  169.00000  115.50000  31.7%     -    0s ## H    0     0                     132.0000000  115.50000  12.5%     -    0s ## H    0     0                     128.0000000  115.50000  9.77%     -    0s ## H    0     0                     127.0000000  115.50000  9.06%     -    0s ##      0     0  118.50000    0    3  127.00000  118.50000  6.69%     -    0s ## H    0     0                     125.0000000  118.50000  5.20%     -    0s ## *    0     0               0     120.0000000  120.00000  0.00%     -    0s ##  ## Cutting planes: ##   Gomory: 2 ##   Cover: 8 ##   MIR: 1 ##  ## Explored 1 nodes (42 simplex iterations) in 0.00 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 8: 120 125 127 ... 964 ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 1.200000000000e+02, best bound 1.200000000000e+02, gap 0.0000% ## ********************************* ##  Iteration 2 of 3: Prop0.3 ## ********************************* ## Warning: The blm argument was set to 0, so the boundary data has no effect  ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0xd3db0e90 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [6e-01, 2e+01] ## Found heuristic solution: objective 964.0000000 ## Found heuristic solution: objective 445.0000000 ## Presolve removed 250 rows and 277 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 119 columns, 237 nonzeros ## Found heuristic solution: objective 241.0000000 ## Variable types: 0 continuous, 119 integer (101 binary) ##  ## Root relaxation: objective 1.865000e+02, 34 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0  186.50000    0    8  241.00000  186.50000  22.6%     -    0s ## H    0     0                     205.0000000  186.50000  9.02%     -    0s ##      0     0  193.00000    0    2  205.00000  193.00000  5.85%     -    0s ## H    0     0                     197.0000000  193.00000  2.03%     -    0s ##      0     0  195.50000    0    3  197.00000  195.50000  0.76%     -    0s ## *    0     0               0     196.0000000  196.00000  0.00%     -    0s ##  ## Cutting planes: ##   Gomory: 2 ##   Cover: 7 ##   MIR: 1 ##   Relax-and-lift: 1 ##  ## Explored 1 nodes (52 simplex iterations) in 0.00 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 6: 196 197 205 ... 964 ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 1.960000000000e+02, best bound 1.960000000000e+02, gap 0.0000% ## ********************************* ##  Iteration 3 of 3: Prop0.4 ## ********************************* ## Warning: The blm argument was set to 0, so the boundary data has no effect  ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0xa62c2e48 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e+00, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [8e-01, 2e+01] ## Found heuristic solution: objective 964.0000000 ## Found heuristic solution: objective 564.0000000 ## Presolve removed 250 rows and 277 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 119 columns, 237 nonzeros ## Found heuristic solution: objective 317.0000000 ## Variable types: 0 continuous, 119 integer (101 binary) ##  ## Root relaxation: objective 2.670000e+02, 43 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0  267.00000    0   10  317.00000  267.00000  15.8%     -    0s ## H    0     0                     290.0000000  267.00000  7.93%     -    0s ## H    0     0                     284.0000000  267.00000  5.99%     -    0s ##      0     0  276.50000    0    6  284.00000  276.50000  2.64%     -    0s ## H    0     0                     279.0000000  276.50000  0.90%     -    0s ##      0     0  276.50000    0    3  279.00000  276.50000  0.90%     -    0s ## H    0     0                     278.0000000  276.50000  0.54%     -    0s ##      0     0     cutoff    0       278.00000  278.00000  0.00%     -    0s ##  ## Explored 1 nodes (68 simplex iterations) in 0.01 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 7: 278 279 284 ... 964 ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 2.780000000000e+02, best bound 2.780000000000e+02, gap 0.0000% # get cost of solutions inside portfolio getCost(port) ##   solution_name monitoring threat_1 threat_2 ## 1       Prop0.2         63       10       47 ## 2       Prop0.3         98       26       72 ## 3       Prop0.4        141       48       89 getConnectivityPenalty(port) ##   solution_name     units threat_1 threat_2 ## 1       Prop0.2  8123.805   904.68 3229.636 ## 2       Prop0.3 11334.252 1760.095 4431.999 ## 3       Prop0.4 12726.708 2336.171 4739.123"},{"path":[]},{"path":"https://josesalgr.github.io/mosap/articles/sensitivities.html","id":"calculating-benefits-when-threats-are-discrete-presenceabsence","dir":"Articles","previous_headings":"","what":"1) Calculating benefits when threats are discrete (presence/absence)","title":"Benefits and sensitivities","text":"order calculate benefit obtained features planning unit threats binary intensities (presence / absence), define probability persistence : pis=∑k∈Ki∩Ksxik|Ki∩Ks| p_{} = \\frac{\\sum_{k \\K_i \\cap K_s} {x_{ik}}}{|K_i \\cap K_s|}  , xikx_{ik} decision variable specifies whether action abate threat kk planning unit ii selected (1) (0), KiK_i set threats exists ii KsK_s set threats feature ss sensitive . Note |Ki∩Ks||K_i \\cap K_s| indicates intersection two sets, , threats exist site ii , turn, features ss sensitive . case intersection zero, means feature ss coexist threats ii, probability persistence 1. Considers two planning objectives (recovery conservation), feature coexist threats (previous case), benefit contributes achieving conservation target (case exist). Otherwise, benefits contribute recovery target. information point can found objectives vignette.","code":""},{"path":"https://josesalgr.github.io/mosap/articles/sensitivities.html","id":"not-proportional-probability-of-persistence","dir":"Articles","previous_headings":"1) Calculating benefits when threats are discrete (presence/absence)","what":"Not proportional probability of persistence","title":"Benefits and sensitivities","text":"seen, probability persistence calculated initially linear relationship actions carried concerning possible actions face threats feature site. However, relationship assumes threats contribute equally probability persistence features. approach estimating probabilities persistence also overestimate benefit addressing threats (e.g., two threats present, one impacting , one -less impacting- addressed). reason, prioriactions incorporates different non-linear curves (vv) exponents original expression pp: bis=pisvris b_{} = p_{}^v r_{}  Thus, vv type curve exponent, three options possible: 1 = linear, 2 = quadratic, 3 = cubic. effect greater higher value parameter. turn, higher , complexity added resolution resulting model , example, likely get solutions almost threats affecting given features given site addressed. curve parameter built prioriactions within problem() function. Let’s see example. show difference models benefit calculation working binary intensities, use two different curves (linear cubic) employing example available Get started vignette. using getCost() can explore total cost solution split actions. obtain total cost 34.4, divided 1.4 monitoring, 14 actions abated threat 1 another 19 actions abated threat 2. Now getSolutionBenefit() function, can obtain benefits distributed different features. Notice use type = \"local\" argument obtain benefits per unit feature.  second model use parameter curve = 3 construction, therefore, calculate probability persistence proportional. Note obtain total cost 39.3, .e. higher cost use linear curve. using getCost(), see fewer units actions carried , suggests actions carried less sites. way previous model, using getSolutionBenefit() function, can obtain benefits distributed different features:  can see, base case, features 1 3 add total benefit sites probability persistence 0.5. Whereas use curve = 3, one site contribute reaching target probability value 1. effect evident threats planning exercise.","code":"# load the prioriactions package library(prioriactions)  data(sim_boundary_data, sim_dist_features_data, sim_dist_threats_data,      sim_features_data, sim_pu_data, sim_sensitivity_data, sim_threats_data)  # set monitoring costs to 0.1 sim_pu_data$monitoring_cost <- 0.1  # set recovery_targets to 15% of maximum sim_features_data$target_recovery <- 0.15 * c(47, 28, 56, 33)  # evaluate input data b.binary_base <- inputData(pu = sim_pu_data,                             features = sim_features_data,                             dist_features = sim_dist_features_data,                             threats = sim_threats_data,                             dist_threats = sim_dist_threats_data,                             sensitivity = sim_sensitivity_data,                             boundary = sim_boundary_data)  # create the mathematic model c.binary_base <- problem(b.binary_base,                           model_type = \"minimizeCosts\") ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases # solve the model d.binary_base <- solve(c.binary_base,                         solver = \"gurobi\",                         verbose = TRUE,                         output_file = FALSE,                        cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 785 nonzeros ## Model fingerprint: 0xda1a7bc4 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e-01, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [4e+00, 8e+00] ## Found heuristic solution: objective 489.0000000 ## Found heuristic solution: objective 146.6000000 ## Presolve removed 262 rows and 319 columns ## Presolve time: 0.00s ## Presolved: 22 rows, 77 columns, 169 nonzeros ## Found heuristic solution: objective 50.6000000 ## Variable types: 0 continuous, 77 integer (63 binary) ##  ## Root relaxation: objective 3.415000e+01, 14 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0   34.15000    0    5   50.60000   34.15000  32.5%     -    0s ## H    0     0                      35.3000000   34.15000  3.26%     -    0s ## *    0     0               0      34.4000000   34.40000  0.00%     -    0s ##  ## Cutting planes: ##   Gomory: 1 ##   Cover: 4 ##   MIR: 2 ##  ## Explored 1 nodes (22 simplex iterations) in 0.00 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 5: 34.4 35.3 50.6 ... 489 ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 3.440000000000e+01, best bound 3.440000000000e+01, gap 0.0000% getCost(d.binary_base) ##   solution_name monitoring threat_1 threat_2 ## 1           sol        1.4       14       19 # get benefits of solution local_benefits <- getSolutionBenefit(d.binary_base, type = \"local\")  # plot local benefits local_benefits <- reshape2::dcast(local_benefits, pu~feature,value.var = \"benefit.total\", fill = 0)  #loead raster package library(raster)   r <- raster(ncol=10, nrow=10, xmn=0, xmx=10, ymn=0, ymx=10) values(r) <- 0  group_rasters <- raster::stack(r, r, r, r) values(group_rasters[[1]]) <- local_benefits$`1` values(group_rasters[[2]]) <- local_benefits$`2` values(group_rasters[[3]]) <- local_benefits$`3` values(group_rasters[[4]]) <- local_benefits$`4`  names(group_rasters) <- c(\"feature 1\", \"feature 2\", \"feature 3\", \"feature 4\") plot(group_rasters) c.binary_curve <- problem(b.binary_base,                     model_type = \"minimizeCosts\",                     curve = 3) ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases d.binary_curve <- solve(c.binary_curve,                   solver = \"gurobi\",                   verbose = TRUE,                   output_file = FALSE,                  cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 572 columns and 785 nonzeros ## Model fingerprint: 0x6afe5081 ## Model has 176 general constraints ## Variable types: 352 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [5e-01, 2e+00] ##   Objective range  [1e-01, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [4e+00, 8e+00] ## Found heuristic solution: objective 489.0000000 ## Presolve added 242 rows and 557 columns ## Presolve time: 0.01s ## Presolved: 526 rows, 1129 columns, 2749 nonzeros ## Presolved model has 164 SOS constraint(s) ## Found heuristic solution: objective 488.0000000 ## Variable types: 984 continuous, 145 integer (140 binary) ##  ## Root relaxation: objective 3.285500e+01, 308 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0   32.85500    0   22  488.00000   32.85500  93.3%     -    0s ## H    0     0                     457.6000000   32.85500  92.8%     -    0s ##      0     0   33.07500    0   19  457.60000   33.07500  92.8%     -    0s ## H    0     0                      51.5000000   33.07500  35.8%     -    0s ##      0     0   33.11500    0   20   51.50000   33.11500  35.7%     -    0s ##      0     0   33.12490    0   32   51.50000   33.12490  35.7%     -    0s ##      0     0   33.13125    0   34   51.50000   33.13125  35.7%     -    0s ## H    0     0                      41.3000000   33.13125  19.8%     -    0s ##      0     0   33.13333    0   27   41.30000   33.13333  19.8%     -    0s ##      0     0   33.13333    0   27   41.30000   33.13333  19.8%     -    0s ##      0     0   33.23750    0   28   41.30000   33.23750  19.5%     -    0s ##      0     0   33.24750    0   18   41.30000   33.24750  19.5%     -    0s ##      0     0   33.24750    0   17   41.30000   33.24750  19.5%     -    0s ##      0     0   33.24750    0   22   41.30000   33.24750  19.5%     -    0s ##      0     0   33.24750    0   22   41.30000   33.24750  19.5%     -    0s ##      0     2   33.26000    0   22   41.30000   33.26000  19.5%     -    0s ## H  109    80                      39.3000000   35.47635  9.73%   3.6    0s ##  37059  1687   38.81870   55    4   39.30000   38.81870  1.22%   2.8    5s ##  ## Cutting planes: ##   Gomory: 1 ##   MIR: 2 ##   Flow cover: 2 ##  ## Explored 48097 nodes (128726 simplex iterations) in 5.95 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 6: 39.3 41.3 51.5 ... 489 ##  ## Optimal solution found (tolerance 0.00e+00) ## Warning: max constraint violation (1.1895e-02) exceeds tolerance ## Warning: max general constraint violation (1.1895e-02) exceeds tolerance ##          (model may be infeasible or unbounded - try turning presolve off) ## Best objective 3.930000000000e+01, best bound 3.930000000000e+01, gap 0.0000% getCost(d.binary_curve) ##   solution_name monitoring threat_1 threat_2 ## 1           sol        1.3       14       24 # get benefits of solution local_benefits.curve <- getSolutionBenefit(d.binary_curve, type = \"local\")  # plot local benefits local_benefits.curve <- reshape2::dcast(local_benefits.curve, pu~feature,value.var = \"benefit.total\", fill = 0)  values(group_rasters[[1]]) <- local_benefits.curve$`1` values(group_rasters[[2]]) <- local_benefits.curve$`2` values(group_rasters[[3]]) <- local_benefits.curve$`3` values(group_rasters[[4]]) <- local_benefits.curve$`4`  plot(group_rasters)"},{"path":"https://josesalgr.github.io/mosap/articles/sensitivities.html","id":"calculating-benefits-when-threats-are-continuous","dir":"Articles","previous_headings":"","what":"2) Calculating benefits when threats are continuous","title":"Benefits and sensitivities","text":"far worked two important premises: 1) threats exist (presence/absence) 2) features equally sensitive threats. make assumptions flexible, introduce possibility using threat intensities (way use risr_{} features) , relationship intensities probability persistence features (response curves). response curves can fitted piece-wise function means four parameters within sensitivities input data, : : minimum intensity threat features probability persistence starts decline. b : value intensity threat feature probability persistence 0. c : minimum probability persistence features threat reaches maximum intensity value. d : maximum probability persistence features absence given threat.  greater intensity threat, lower probability persistence feature. Thus, definition four parameters mentioned , different response curves can fitted:  latter examples curves fitted parameters; can customized users according needs using four parameters detailed . Note curves relationship feature particular threat, happens probability persistence feature coexists one threats?. can define probability persistence feature ss unit ii measure individual probability persistence feature ss respect threat kk unit ii (piskp_{isk}), .e.: pis=∑k∈Ki∩Ksγiskpisk p_{} = \\sum_{k \\K_i \\cap K_s}\\gamma_{isk} p_{isk} ∑k∈|Ki∩Ks|γisk=1\\sum_{k \\|K_i \\cap K_s|}\\gamma_{isk} = 1 γisk=γisk′∀k,k′∈|Ki∩Ks|\\gamma_{isk} = \\gamma_{isk'} \\forall k, k' \\|K_i \\cap K_s|. prioriactions package internally calculates values γisk\\gamma_{isk} reflecting relative importance threat (considering potential danger) calculating probability persistence feature. Note probability persistence feature different zero even actions taken (depending type response curve). implies nothing (actions) unit lead , although small, benefits. benefits considered raise targets regardless planning objective. Finally, probability persistence resulting can calculated : pis=∑k∈Ki∩Ks:ask<=hik<=bskxik(hik−ask)(dsk−csk)bsk−ask(1−csk(hik−ask)−dsk(hik−bsk)bsk−ask+∑k∈Ki∩Ks:hik>bskxik(1−csk)(dsk−csk)∑k∈Ki∩Ks:hik<ask1−dsk+∑k∈Ki∩Ks:ask<=hik<=bsk1−csk(hik−ask)−dsk(hik−bsk)bsk−ask+∑kinKi∩Ks:hik>bsk1−csk p_{} = \\frac{{\\sum_{k \\K_i \\cap K_s: a_{sk} <= h_{ik} <= b_{sk}} \\frac{x_{ik} (h_{ik} - a_{sk})(d_{sk} - c_{sk})}{b_{sk} - a_{sk}}  (1 - \\frac{c_{sk}(h_{ik} - a_{sk}) - d_{sk}(h_{ik} - b_{sk})}{b_{sk} - a_{sk}}+ \\sum_{k \\K_i \\cap K_s: h_{ik} > b_{sk}} x_{ik}(1- c_{sk})(d_{sk} - c_{sk})}}{  {\\sum_{k \\K_i \\cap K_s: h_{ik} < a_{sk}}  1 - d_{sk}} + \\sum_{k \\K_i \\cap K_s: a_{sk} <= h_{ik} <= b_{sk}} 1 - \\frac{c_{sk}(h_{ik} - a_{sk}) - d_{sk}(h_{ik} - b_{sk})}{b_{sk} - a_{sk}}+ \\sum_{k K_i \\cap K_s: h_{ik} > b_{sk}} 1 - c_{sk}}  hikh_{ik} intensity threat kk unit ii.","code":""},{"path":"https://josesalgr.github.io/mosap/articles/sensitivities.html","id":"example-with-continuous-intensities-of-threats","dir":"Articles","previous_headings":"2) Calculating benefits when threats are continuous","what":"Example with continuous intensities of threats","title":"Benefits and sensitivities","text":"order demonstrate use package continuous values intensities, use example considered models binary threat intensities. Note examples compared due differences potential benefits therefore targets used. Also, assume information sensitivity feature 1 threats, whose response curves fitted follow:  Note feature sensitive intensity threat-1, less sensitive threat 2, probability persistence remains invariant threat reaches high intensity values. First, add parameters aa, bb input sensitivities, leaving measures know NA. pioriractions responsible assuming default values; example, parameter aa, considered values provided 0, bb, value maximum intensity said threat case study, cc 0 dd 1. addition, simulate intensity threats continuously using runif() function; values 0 150 threat 1 values 0 1 threat 2. Note maximum benefits achieved changed due presence intensities threats sensitivity curves (respect base model). can use getPotentialBenefit() explore difference benefits: Now getSolutionBenefit() function, can obtain benefits distributed different features. Notice use type = \"local\" argument obtain benefits per unit feature.  Note selected sites differ greater extent chosen base model binary threat intensities. , effect can bring use sensitivities intensities continuous threats management conservation actions extracted.","code":"# set a,b,c and d parameters sim_sensitivity_data$a = c(0, NA, NA, NA, 0.8, NA, NA, NA) sim_sensitivity_data$b = c(150, NA, NA, NA, 1, NA, NA, NA) sim_sensitivity_data$c = 0.0 sim_sensitivity_data$d = c(1, NA, NA, NA, 0.6, NA, NA, NA)  # set continuous intensities set.seed(1)  sim_dist_threats_data$amount[sim_dist_threats_data$threat == 1] <- round(runif(n = 57, 0, 123), 2) sim_dist_threats_data$amount[sim_dist_threats_data$threat == 2] <- round(runif(n = 63, 0, 1), 2)  # evaluate input data b.continuous <- inputData(pu = sim_pu_data,                             features = sim_features_data,                             dist_features = sim_dist_features_data,                             threats = sim_threats_data,                             dist_threats = sim_dist_threats_data,                             sensitivity = sim_sensitivity_data,                             boundary = sim_boundary_data)  # set the target of recovery to 15% max <- getPotentialBenefit(b.continuous) sim_features_data$target_recovery <- 0.15 * max$maximum.recovery.benefit  # evaluate input data b.continuous <- inputData(pu = sim_pu_data,                             features = sim_features_data,                             dist_features = sim_dist_features_data,                             threats = sim_threats_data,                             dist_threats = sim_dist_threats_data,                             sensitivity = sim_sensitivity_data,                             boundary = sim_boundary_data)  # create the mathematic model c.continuous <- problem(b.continuous,                           model_type = \"minimizeCosts\") ## Warning: The blm argument was set to 0, so the boundary data has no effect ## Warning: Some blm_actions argument were set to 0, so the boundary data has no effect for these cases # solve the model d.continuous <- solve(c.continuous,                         solver = \"gurobi\",                         verbose = TRUE,                         output_file = FALSE,                        cores = 2) ## Gurobi Optimizer version 9.1.2 build v9.1.2rc0 (linux64) ## Thread count: 2 physical cores, 4 logical processors, using up to 2 threads ## Optimize a model with 284 rows, 396 columns and 766 nonzeros ## Model fingerprint: 0xfea67198 ## Variable types: 176 continuous, 220 integer (220 binary) ## Coefficient statistics: ##   Matrix range     [2e-04, 2e+00] ##   Objective range  [1e-01, 1e+01] ##   Bounds range     [1e+00, 1e+00] ##   RHS range        [2e+00, 5e+00] ## Found heuristic solution: objective 153.7000000 ## Presolve removed 250 rows and 248 columns ## Presolve time: 0.00s ## Presolved: 34 rows, 148 columns, 278 nonzeros ## Found heuristic solution: objective 42.4000000 ## Variable types: 0 continuous, 148 integer (146 binary) ##  ## Root relaxation: objective 2.011896e+01, 17 iterations, 0.00 seconds ##  ##     Nodes    |    Current Node    |     Objective Bounds      |     Work ##  Expl Unexpl |  Obj  Depth IntInf | Incumbent    BestBd   Gap | It/Node Time ##  ##      0     0   20.11896    0    9   42.40000   20.11896  52.5%     -    0s ## H    0     0                      29.1000000   20.11896  30.9%     -    0s ## H    0     0                      21.9000000   20.11896  8.13%     -    0s ## H    0     0                      21.8000000   20.11896  7.71%     -    0s ##      0     0   20.82302    0    3   21.80000   20.82302  4.48%     -    0s ##      0     0   20.91403    0    3   21.80000   20.91403  4.06%     -    0s ##      0     0   21.21879    0    4   21.80000   21.21879  2.67%     -    0s ##      0     0   21.47599    0    5   21.80000   21.47599  1.49%     -    0s ##      0     0   21.53170    0    5   21.80000   21.53170  1.23%     -    0s ##      0     0   21.54367    0    6   21.80000   21.54367  1.18%     -    0s ##      0     0   21.58911    0    6   21.80000   21.58911  0.97%     -    0s ##      0     0   21.59162    0    7   21.80000   21.59162  0.96%     -    0s ##      0     0   21.59578    0    8   21.80000   21.59578  0.94%     -    0s ##      0     0   21.61294    0    8   21.80000   21.61294  0.86%     -    0s ##      0     0     cutoff    0        21.80000   21.80000  0.00%     -    0s ##  ## Cutting planes: ##   Gomory: 2 ##   Cover: 3 ##   MIR: 1 ##   StrongCG: 2 ##   RLT: 1 ##  ## Explored 1 nodes (56 simplex iterations) in 0.01 seconds ## Thread count was 2 (of 4 available processors) ##  ## Solution count 5: 21.8 21.9 29.1 ... 153.7 ##  ## Optimal solution found (tolerance 0.00e+00) ## Best objective 2.180000000000e+01, best bound 2.180000000000e+01, gap 0.0000% # get potential benefits getPotentialBenefit(b.continuous) ##   feature dist dist_threatened maximum.conservation.benefit maximum.recovery.benefit maximum.benefit ## 1       1   47              47                            0                  13.7781         13.7781 ## 2       2   30              28                            2                  14.6788         16.6788 ## 3       3   66              56                           10                  32.9739         42.9739 ## 4       4   33              33                            0                  15.9912         15.9912 # get benefits of solution local_benefits.continuous<- getSolutionBenefit(d.continuous, type = \"local\")  # plot local benefits local_benefits.continuous <- reshape2::dcast(local_benefits.continuous, pu~feature,value.var = \"benefit.total\", fill = 0)  values(group_rasters[[1]]) <- local_benefits.continuous$`1` values(group_rasters[[2]]) <- local_benefits.continuous$`2` values(group_rasters[[3]]) <- local_benefits.continuous$`3` values(group_rasters[[4]]) <- local_benefits.continuous$`4`  plot(group_rasters)"},{"path":[]},{"path":"https://josesalgr.github.io/mosap/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jose Salgado-Rojas. Author, maintainer. Nuria Aquilue. Author.","code":""},{"path":"https://josesalgr.github.io/mosap/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Salgado-Rojas J, Aquilue N (2026). mosap: Integrated Multi-Objective Spatial Action Planning. R package version 1.0.1, https://josesalgr.github.io/mosap/.","code":"@Manual{,   title = {mosap: Integrated Multi-Objective Spatial Action Planning},   author = {Jose Salgado-Rojas and Nuria Aquilue},   year = {2026},   note = {R package version 1.0.1},   url = {https://josesalgr.github.io/mosap/}, }"},{"path":"https://josesalgr.github.io/mosap/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to prioriactions","title":"Contributing to prioriactions","text":"First , thanks considering contributing prioriactions. greatly appreciate interest improving expanding package. prioriactions result collaborative work programmers experts different disciplines. Since successful modelling projects involve long-term investments participation multiple teams, open expanding set people contributing project. people much welcome contribute code, documentation, testing suggestions.","code":""},{"path":"https://josesalgr.github.io/mosap/CONTRIBUTING.html","id":"fixing-typos-and-documentation","dir":"","previous_headings":"","what":"Fixing typos and documentation","title":"Contributing to prioriactions","text":"contents website produced utilization pkgdown R package. implies ’s need manual HTML coding; website’s content automatically aggregated various sources including code documentation, vignettes, Markdown files. ’re familiar using pkgdown, ’re welcome suggest modifications enhance documentation submitting file change. ’re acquainted pkgdown, feel free raise issue.","code":""},{"path":"https://josesalgr.github.io/mosap/CONTRIBUTING.html","id":"report-a-bug","dir":"","previous_headings":"","what":"Report a bug","title":"Contributing to prioriactions","text":"want report bug suggest enhancement, ’s good idea file issue prioriactions repository GitHub. ’ve found bug, please file issue illustrates bug minimal reprex.","code":""},{"path":"https://josesalgr.github.io/mosap/CONTRIBUTING.html","id":"ask-a-question","dir":"","previous_headings":"","what":"Ask a question","title":"Contributing to prioriactions","text":"Using prioriactions got stuck? Browse documentation see can find solution. Still stuck? Post question issue GitHub. offer user support, ’ll try best address , questions often lead better documentation discovery bugs. want ask question private, can contact package maintainer José Salgado-Rojas.","code":""},{"path":"https://josesalgr.github.io/mosap/CONTRIBUTING.html","id":"propose-an-idea","dir":"","previous_headings":"","what":"Propose an idea","title":"Contributing to prioriactions","text":"idea new feature prioriactions? Take look documentation issue list see isn’t already included suggested. , suggest idea issue GitHub. can’t promise implement every idea, certainly helps : Explain detail proposed feature work. Keep scope narrow possible ensure feasibility. See want contribute code idea well.","code":""},{"path":"https://josesalgr.github.io/mosap/CONTRIBUTING.html","id":"code-contributions","dir":"","previous_headings":"","what":"Code contributions","title":"Contributing to prioriactions","text":"making contributions package R C++ code, make sure someone prioriactions team agrees change suggest needed. Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"prioriactions/prioriactions\", fork = TRUE). Install development dependences devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://josesalgr.github.io/mosap/index.html","id":"mosap-integrated-multi-objective-spatial-action-planning","dir":"","previous_headings":"","what":"Integrated Multi-Objective Spatial Action Planning","title":"Integrated Multi-Objective Spatial Action Planning","text":"⚠️ Experimental package: mosap experimental research package active development. Breaking changes may occur time (API, internal tables, solver interfaces, outputs). Use risk rely production workflows yet.","code":""},{"path":"https://josesalgr.github.io/mosap/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Integrated Multi-Objective Spatial Action Planning","text":"mosap designed support atomic objectives (e.g., minimize cost, minimize fragmentation, maximize benefits) combine multi-objective methods (e.g., weighted sum). package supports tabular spatial inputs (vector- raster-based workflows), stores intermediate artifacts (tables, spatial relations, targets, solver configuration) enable reproducible experimentation reporting.","code":""},{"path":"https://josesalgr.github.io/mosap/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Integrated Multi-Objective Spatial Action Planning","text":"latest development version mosap can installed GitHub:","code":"if (!require(remotes)) install.packages(\"remotes\") remotes::install_github(\"josesalgr/mosap\")"},{"path":"https://josesalgr.github.io/mosap/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Integrated Multi-Objective Spatial Action Planning","text":"minimal end--end example showing intended pipeline. believe ’ve found bug mosap, please file issue (ideally reproducible example) : https://github.com/josesalgr/mosap/issues.","code":"library(mosap)  # --- Example inputs (replace with your own) # pu_data            : data.frame(id, cost, locked_in?, locked_out?) # features_data      : data.frame(id, name) # dist_features_data : data.frame(pu, feature, amount)  # 1) Build the Data object x <- inputData(   pu = pu_data,   features = features_data,   dist_features = dist_features_data )  # 2) Add actions/effects/targets/spatial relations as needed x <- x |>   add_actions(actions_df) |>   add_effects(effects_df) |>   add_conservation_targets_relative(0.17) |>   add_spatial_boundary()  # 3) Register atomic objectives (aliases are later used by MO methods) x <- x |>   add_objective_min_cost(alias = \"cost\") |>   add_objective_min_fragmentation(alias = \"frag\")  # 4) Configure a multi-objective method (weighted sum) mo <- set_method_weighted(   x,   aliases = c(\"cost\", \"frag\"),   weights = c(1, 1),   normalize = TRUE )  # 5) Configure solver (example; adapt to your solver and preferences) mo <- set_solver(   mo,   solver = \"auto\",   time_limit = 60,   gap_limit = 0.01,   verbose = TRUE )  # 6) Solve res <- solve(mo)  # 7) Inspect results (examples) get_pu(res, only_selected = TRUE) get_actions(res, only_selected = TRUE) get_features(res) get_targets(res)"},{"path":"https://josesalgr.github.io/mosap/reference/add_actions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add actions to a planning problem — add_actions","title":"Add actions to a planning problem — add_actions","text":"Define set management actions, can implemented (feasibility), costs, optional lock status per (pu, action) pair. function stores action catalogue x$data$actions feasible action distribution x$data$dist_actions. Feasibility controlled via include / exclude: include NULL feasible_default = TRUE, (pu, action) pairs feasible. include provided, (pu, action) pairs feasible. exclude provided, (pu, action) pairs removed feasible set (either full set include).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_actions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add actions to a planning problem — add_actions","text":"","code":"add_actions(   x,   actions,   include = NULL,   exclude = NULL,   cost = NULL,   status = NULL,   feasible_default = TRUE,   na_is_infeasible = TRUE,   sort_actions = TRUE )"},{"path":"https://josesalgr.github.io/mosap/reference/add_actions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add actions to a planning problem — add_actions","text":"x Data object created inputData inputDataSpatial. Must contain least x$data$pu, x$data$features, x$data$dist_features. actions data.frame defining action catalogue. Must contain unique id column (action identifiers). backwards compatibility, column named action also accepted renamed id. Additional columns kept. include Optional feasibility specification. provided, (pu, action) pairs feasible. Accepts NULL, data.frame, named list (see Details). exclude Optional infeasibility specification. Removed feasible set defined include (full set include NULL feasible_default = TRUE). Accepts formats include. cost Optional cost specification feasible (pu, action) pairs. Accepts: NULL: default cost = 1 pairs, single numeric scalar, named numeric vector (names = action ids), data.frame(action, cost) data.frame(pu, action, cost). status Optional data.frame columns pu, action, status specifying lock status feasible pairs. Status must {0, 2, 3}. feasible_default Logical. include NULL, actions feasible planning units? FALSE include NULL, function errors. na_is_infeasible Logical. relevant include/exclude provided data.frames feasible column. TRUE, treat NA FALSE. sort_actions Logical. TRUE, sort actions id assigning internal ids.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_actions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add actions to a planning problem — add_actions","text":"updated Data object : x$data$actions: action catalogue including internal_id, x$data$dist_actions: feasible (pu, action) pairs columns pu, action, cost, status, internal_pu, internal_action, x$data$index$pu x$data$index$action: id--internal-id mappings. updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_actions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add actions to a planning problem — add_actions","text":"Accepted formats include exclude: NULL: restriction (valid include feasible_default = TRUE). data.frame columns pu action. optional feasible column supported filter (rows feasible == TRUE used). na_is_infeasible = TRUE, NA values feasible treated FALSE. Action ids must match actions$id, PU ids must match x$data$pu$id. named list names equal action ids. element can : integer vector PU ids, sf object defining spatial zone action. Spatial feasibility: include/exclude provided sf layers, feasibility computed using spatial predicates (geometries cut). Specifically, planning units x$data$pu_sf matched zones via sf::st_intersects(). procedure create new planning unit geometries. Costs: costs can specified single scalar applied feasible pairs, named numeric vector action id, data.frame providing costs action (action, cost) pair (pu, action, cost). Costs must finite non-negative. Locks: status can set lock status specific feasible pairs. Status must one 0 (free), 2 (locked-), 3 (locked-). x$data$pu contains logical locked_out column, action pairs PUs forced status = 3.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/add_actions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add actions to a planning problem — add_actions","text":"","code":"if (FALSE) { # \\dontrun{ # Action catalogue actions_df <- data.frame(id = c(\"harvest\", \"sustainable\", \"restoration\"))  # 1) Full feasibility (all actions everywhere), constant cost p <- add_actions(p, actions = actions_df, cost = 10)  # 2) Only allow some pairs (include) include_df <- data.frame(   pu = c(1, 2, 10),   action = c(\"harvest\", \"harvest\", \"restoration\") ) p <- add_actions(p, actions = actions_df, include = include_df, cost = 10)  # 3) Allow everything except some impossible pairs (exclude) exclude_df <- data.frame(pu = c(1, 2, 3, 5), action = \"harvest\") p <- add_actions(p, actions = actions_df, exclude = exclude_df, cost = 10)  # 4) Feasibility as a named list (PU ids per action) include_list <- list(   harvest = c(1, 2, 3),   restoration = c(10, 11) ) p <- add_actions(p, actions = actions_df, include = include_list)  # 5) Action-specific costs (named vector) costs <- c(harvest = 5, sustainable = 2, restoration = 8) p <- add_actions(p, actions = actions_df, cost = costs)  # 6) Lock status for specific pairs st <- data.frame(pu = c(1, 10), action = c(\"harvest\", \"restoration\"), status = c(3L, 2L)) p <- add_actions(p, actions = actions_df, status = st) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_action_max_per_pu.html","id":null,"dir":"Reference","previous_headings":"","what":"Limit the number of actions per planning unit (maximum) — add_action_max_per_pu","title":"Limit the number of actions per planning unit (maximum) — add_action_max_per_pu","text":"Store constraint limits number actions can selected within planning unit (PU). constraint form: $$\\sum_{\\} x_{pu,} \\le \\mathrm{max}$$ PU selected set. function data-: records constraint specification Data object build modify optimization model. constraint later translated linear constraints model builder (e.g., .pa_build_model_apply_constraints()).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_action_max_per_pu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Limit the number of actions per planning unit (maximum) — add_action_max_per_pu","text":"","code":"add_action_max_per_pu(   x,   max = 1L,   pu = NULL,   actions = NULL,   overwrite = FALSE )"},{"path":"https://josesalgr.github.io/mosap/reference/add_action_max_per_pu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Limit the number of actions per planning unit (maximum) — add_action_max_per_pu","text":"x Data object created inputData inputDataSpatial. Must already contain actions (.e., run add_actions first). max Integer scalar \\(\\ge 0\\). Maximum number actions allowed per PU. Default 1L. pu Optional integer vector planning unit ids (external ids, .e., x$data$pu$id) constraint applied. NULL (default), constraint applies PUs. actions Optional character vector action ids (.e., x$data$actions$id) include sum. NULL (default), actions included. overwrite Logical. TRUE, replace existing action_max_per_pu constraint stored x$data$constraints. FALSE (default) constraint already exists, error raised.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_action_max_per_pu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Limit the number of actions per planning unit (maximum) — add_action_max_per_pu","text":"updated Data object x$data$constraints$action_max_per_pu set list containing constraint specification.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_action_max_per_pu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Limit the number of actions per planning unit (maximum) — add_action_max_per_pu","text":"constraint can applied : planning units actions (default), subset planning units via pu, /subset actions via actions. Note subset applied existing feasible (pu, action) pairs x$data$dist_actions. requested pu/actions subset yields zero feasible pairs, function stops informative error. x$data$model_ptr already present (model built previously), function marks model dirty setting x$data$meta$model_dirty <- TRUE, signalling model rebuilt solving.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/add_action_max_per_pu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Limit the number of actions per planning unit (maximum) — add_action_max_per_pu","text":"","code":"if (FALSE) { # \\dontrun{ # Limit to at most 1 action per PU (default) p <- add_action_max_per_pu(p, max = 1)  # Limit to at most 2 actions per PU p <- add_action_max_per_pu(p, max = 2, overwrite = TRUE)  # Apply the limit only to a subset of PUs p <- add_action_max_per_pu(p, max = 1, pu = c(1, 2, 3), overwrite = TRUE)  # Limit the number of actions among a subset of actions (e.g., only harvest-like actions) p <- add_action_max_per_pu(p, max = 1, actions = c(\"harvest\", \"sustainable\"), overwrite = TRUE)  # Combine PU and action subsets p <- add_action_max_per_pu(   p, max = 1,   pu = c(10, 11, 12),   actions = c(\"harvest\", \"sustainable\"),   overwrite = TRUE ) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_area_max_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add maximum selected area constraint — add_area_max_constraint","title":"Add maximum selected area constraint — add_area_max_constraint","text":"Add linear constraint enforcing maximum total selected area using planning unit selection variables \\(w_i\\): $$\\sum_i \\mathrm{area}_i \\, w_i \\le A_{\\max}.$$","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_area_max_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add maximum selected area constraint — add_area_max_constraint","text":"","code":"add_area_max_constraint(   x,   area_max,   area_col = NULL,   area_unit = c(\"m2\", \"ha\", \"km2\"),   name = \"area_max\" )"},{"path":"https://josesalgr.github.io/mosap/reference/add_area_max_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add maximum selected area constraint — add_area_max_constraint","text":"x Data object. area_max Numeric scalar \\(\\ge 0\\). Maximum area select (expressed area_unit). area_col Optional character. Name column x$data$pu containing areas. NULL, areas obtained using internal defaults (see Details). area_unit Character. Units area_max. One \"m2\", \"ha\", \"km2\". name Character. Name constraint model. Default \"area_max\".","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_area_max_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add maximum selected area constraint — add_area_max_constraint","text":"updated Data object new linear constraint added model metadata stored x$data$constraints$area_max.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_area_max_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add maximum selected area constraint — add_area_max_constraint","text":"function adds linear constraint current optimization model snapshot. Areas retrieved planning unit table (x$data$pu) via area_col via package defaults implemented .pa_get_area_vec(), converted requested area_unit. coefficient vector aligned model's planning unit order (n_pu internal \\(w\\) variable offset stored x$data$model_list). Constraint metadata also stored x$data$constraints$area_max printing/reporting.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/add_area_max_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add maximum selected area constraint — add_area_max_constraint","text":"","code":"if (FALSE) { # \\dontrun{ # Enforce selecting at most 500 km2 p <- add_area_max_constraint(p, area_max = 500, area_unit = \"km2\")  # Use a custom area column stored in x$data$pu$area_m2 p <- add_area_max_constraint(p, area_max = 2e6, area_unit = \"m2\", area_col = \"area_m2\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_area_min_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add minimum selected area constraint — add_area_min_constraint","title":"Add minimum selected area constraint — add_area_min_constraint","text":"Add linear constraint enforcing minimum total selected area using planning unit selection variables \\(w_i\\): $$\\sum_i \\mathrm{area}_i \\, w_i \\ge A_{\\min}.$$","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_area_min_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add minimum selected area constraint — add_area_min_constraint","text":"","code":"add_area_min_constraint(   x,   area_min,   area_col = NULL,   area_unit = c(\"m2\", \"ha\", \"km2\"),   name = \"area_min\" )"},{"path":"https://josesalgr.github.io/mosap/reference/add_area_min_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add minimum selected area constraint — add_area_min_constraint","text":"x Data object. area_min Numeric scalar \\(\\ge 0\\). Minimum area select (expressed area_unit). area_col Optional character. Name column x$data$pu containing areas. NULL, areas obtained using internal defaults (see Details). area_unit Character. Units area_min. One \"m2\", \"ha\", \"km2\". name Character. Name constraint model. Default \"area_min\".","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_area_min_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add minimum selected area constraint — add_area_min_constraint","text":"updated Data object new linear constraint added model metadata stored x$data$constraints$area_min.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_area_min_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add minimum selected area constraint — add_area_min_constraint","text":"function adds linear constraint current optimization model snapshot. Areas retrieved planning unit table (x$data$pu) via area_col via package defaults implemented .pa_get_area_vec(), converted requested area_unit. coefficient vector aligned model's planning unit order (n_pu internal \\(w\\) variable offset stored x$data$model_list). Constraint metadata also stored x$data$constraints$area_min printing/reporting.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/add_area_min_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add minimum selected area constraint — add_area_min_constraint","text":"","code":"if (FALSE) { # \\dontrun{ # Enforce selecting at least 1000 ha p <- add_area_min_constraint(p, area_min = 1000, area_unit = \"ha\")  # Use a custom area column stored in x$data$pu$Area_km2 p <- add_area_min_constraint(p, area_min = 250, area_unit = \"km2\", area_col = \"Area_km2\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_benefits.html","id":null,"dir":"Reference","previous_headings":"","what":"Add benefits (positive effects) — add_benefits","title":"Add benefits (positive effects) — add_benefits","text":"Convenience wrapper around add_effects keeps rows benefit > 0 (.e., positive changes). backwards compatibility, argument benefits alias effects. addition writing x$data$dist_effects, function also writes backward-compatible table x$data$dist_benefit containing benefit component.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_benefits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add benefits (positive effects) — add_benefits","text":"","code":"add_benefits(   x,   benefits = NULL,   ...,   effect_type = c(\"delta\", \"after\"),   effect_aggregation = c(\"sum\", \"mean\"),   align_rasters = TRUE,   keep_zero = FALSE,   drop_locked_out = TRUE,   na_to_zero = TRUE )"},{"path":"https://josesalgr.github.io/mosap/reference/add_benefits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add benefits (positive effects) — add_benefits","text":"x Data object created inputData inputDataSpatial. Must contain x$data$dist_actions (run add_actions first). benefits Alias effects backwards compatibility. effect_type Character. interpret provided values explicit tables raster lists: \"delta\": values represent signed deltas (default), \"\": values represent -action amounts (converted deltas using baseline). effect_aggregation Character. Aggregation used compute PU-level values rasters. One \"sum\" \"mean\". align_rasters Logical. TRUE, attempt align effect rasters PU raster grid zonal operations (default TRUE). keep_zero Logical. TRUE, keep rows benefit == 0 loss == 0. Default FALSE. drop_locked_out Logical. TRUE, drop rows (pu, action) pairs status == 3 x$data$dist_actions (column exists). Default TRUE. na_to_zero Logical. TRUE, treat missing values 0 computing benefit/loss. Default TRUE.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_benefits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add benefits (positive effects) — add_benefits","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_absolute.html","id":null,"dir":"Reference","previous_headings":"","what":"Add conservation targets (absolute) — add_conservation_targets_absolute","title":"Add conservation targets (absolute) — add_conservation_targets_absolute","text":"Adds absolute conservation targets per feature. provided values treated absolute thresholds units feature amounts stored x$data$dist_features$amount.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_absolute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add conservation targets (absolute) — add_conservation_targets_absolute","text":"","code":"add_conservation_targets_absolute(x, targets, overwrite = FALSE, label = NULL)"},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_absolute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add conservation targets (absolute) — add_conservation_targets_absolute","text":"x data object. targets Target specification. See Targets format targets details. overwrite Logical. TRUE, replace existing conservation targets features. label Optional character label stored targets (useful reporting).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_absolute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add conservation targets (absolute) — add_conservation_targets_absolute","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_relative.html","id":null,"dir":"Reference","previous_headings":"","what":"Add conservation targets (relative to baseline) — add_conservation_targets_relative","title":"Add conservation targets (relative to baseline) — add_conservation_targets_relative","text":"Adds relative conservation targets proportions \\([0,1]\\) baseline total representation feature study area. Baseline totals computed input data (via .pa_feature_totals()).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_relative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add conservation targets (relative to baseline) — add_conservation_targets_relative","text":"","code":"add_conservation_targets_relative(x, targets, overwrite = FALSE, label = NULL)"},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_relative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add conservation targets (relative to baseline) — add_conservation_targets_relative","text":"x data object. targets Target specification (proportions \\([0,1]\\)). overwrite Logical. TRUE, replace existing conservation targets features. label Optional character label stored targets.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_conservation_targets_relative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add conservation targets (relative to baseline) — add_conservation_targets_relative","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_effects.html","id":null,"dir":"Reference","previous_headings":"","what":"Add effects (benefit/loss) to a planning problem — add_effects","title":"Add effects (benefit/loss) to a planning problem — add_effects","text":"Define ecological (feature-based) effects implementing actions planning units. Effects stored x$data$dist_effects two non-negative components per feasible (pu, action, feature) triple: benefit \\(\\ge 0\\): positive change (improvement), loss \\(\\ge 0\\): magnitude negative change (damage), computed loss = -min(delta, 0).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_effects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add effects (benefit/loss) to a planning problem — add_effects","text":"","code":"add_effects(   x,   effects = NULL,   effect_type = c(\"delta\", \"after\"),   effect_aggregation = c(\"sum\", \"mean\"),   align_rasters = TRUE,   keep_zero = FALSE,   drop_locked_out = TRUE,   na_to_zero = TRUE,   filter = c(\"any\", \"benefit\", \"loss\") )"},{"path":"https://josesalgr.github.io/mosap/reference/add_effects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add effects (benefit/loss) to a planning problem — add_effects","text":"x Data object created inputData inputDataSpatial. Must contain x$data$dist_actions (run add_actions first). effects Effect specification. One : NULL: store empty effects table. data.frame(action, feature, multiplier): apply signed multipliers baseline amounts. feature may feature ids feature names (matching x$data$features$name). data.frame(pu, action, feature, ...): explicit effects one : delta (signed) effect (signed), (-action amount; set effect_type = \"\"), benefit /loss (non-negative; missing component treated 0), legacy signed benefit without loss (treated signed delta). named list terra::SpatRaster objects: names = action ids; one layer per feature. effect_type Character. interpret provided values explicit tables raster lists: \"delta\": values represent signed deltas (default), \"\": values represent -action amounts (converted deltas using baseline). effect_aggregation Character. Aggregation used compute PU-level values rasters. One \"sum\" \"mean\". align_rasters Logical. TRUE, attempt align effect rasters PU raster grid zonal operations (default TRUE). keep_zero Logical. TRUE, keep rows benefit == 0 loss == 0. Default FALSE. drop_locked_out Logical. TRUE, drop rows (pu, action) pairs status == 3 x$data$dist_actions (column exists). Default TRUE. na_to_zero Logical. TRUE, treat missing values 0 computing benefit/loss. Default TRUE. filter Character. Filter rows non-zero component: \"\": keep benefit loss rows (default), \"benefit\": keep rows benefit > 0, \"loss\": keep rows loss > 0.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_effects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add effects (benefit/loss) to a planning problem — add_effects","text":"updated Data object x$data$dist_effects created/updated, metadata stored x$data$effects_meta.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_effects.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add effects (benefit/loss) to a planning problem — add_effects","text":"Internally, effects may originate signed values (deltas) -action amounts. Regardless input, dist_effects always stores benefit loss non-negative values avoid ambiguity support models separately account gains damages. Baseline -action amounts. effect_type = \"\", provided values interpreted -action amounts converted signed deltas using baseline amounts x$data$dist_features$amount: $$\\mathrm{delta} = \\mathrm{} - \\mathrm{baseline}.$$ Missing baseline values treated 0. Supported effect specifications. NULL: store empty effects table (recommended default effects available yet). Multipliers: data.frame(action, feature, multiplier) applies signed multiplier baseline amounts: \\(\\mathrm{delta} = \\mathrm{amount} \\times \\mathrm{multiplier}\\). Explicit rows: data.frame(pu, action, feature, ...) providing either signed deltas (delta effect, legacy signed benefit), -action amounts (), already split non-negative benefit/loss. Rasters per action: named list terra::SpatRaster objects (names action ids), one layer per feature. Raster values aggregated planning unit using effect_aggregation interpreted deltas -action amounts depending effect_type. Feasibility locks. Effects retained feasible (pu, action) pairs present x$data$dist_actions. drop_locked_out = TRUE x$data$dist_actions$status exists, pairs status == 3 excluded effects processed. Filtering. can keep beneficial effects (benefit > 0) losses (loss > 0) using filter. default, rows benefit == 0 loss == 0 dropped unless keep_zero = TRUE.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/add_effects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add effects (benefit/loss) to a planning problem — add_effects","text":"","code":"if (FALSE) { # \\dontrun{ # 1) Empty effects (default) p <- add_effects(p, effects = NULL)  # 2) Multipliers (action x feature): delta = amount * multiplier mult <- data.frame(   action = c(\"harvest\", \"harvest\", \"restoration\"),   feature = c(\"sp1\", \"sp2\", \"sp1\"),      # feature names (requires x$data$features$name)   multiplier = c(-0.2, -0.1, 0.3) ) p <- add_effects(p, effects = mult, effect_type = \"delta\")  # 3) Explicit deltas by (pu, action, feature) eff <- data.frame(   pu = c(1, 1, 2),   action = c(\"harvest\", \"harvest\", \"restoration\"),   feature = c(1, 2, 1),   delta = c(-0.5, 0.2, 1.0) ) p <- add_effects(p, effects = eff)  # 4) After-action amounts (converted to delta = after - baseline) after_tbl <- transform(eff, after = delta) # example only; typically after is an absolute amount p <- add_effects(p, effects = after_tbl, effect_type = \"after\")  # 5) Raster effects per action (one layer per feature) # effects_rasters <- list(harvest = r_harv, restoration = r_rest) # terra::SpatRaster # p <- add_effects(p, effects = effects_rasters, effect_type = \"delta\", effect_aggregation = \"sum\")  # Keep only beneficial effects p <- add_effects(p, effects = eff, filter = \"benefit\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_losses.html","id":null,"dir":"Reference","previous_headings":"","what":"Add losses (negative effects magnitude) — add_losses","title":"Add losses (negative effects magnitude) — add_losses","text":"Convenience wrapper around add_effects keeps rows loss > 0 (.e., magnitude negative changes). Also writes x$data$dist_loss containing loss component.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_losses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add losses (negative effects magnitude) — add_losses","text":"","code":"add_losses(   x,   losses = NULL,   ...,   effect_type = c(\"delta\", \"after\"),   effect_aggregation = c(\"sum\", \"mean\"),   align_rasters = TRUE,   keep_zero = FALSE,   drop_locked_out = TRUE,   na_to_zero = TRUE )"},{"path":"https://josesalgr.github.io/mosap/reference/add_losses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add losses (negative effects magnitude) — add_losses","text":"x Data object created inputData inputDataSpatial. Must contain x$data$dist_actions (run add_actions first). effect_type Character. interpret provided values explicit tables raster lists: \"delta\": values represent signed deltas (default), \"\": values represent -action amounts (converted deltas using baseline). effect_aggregation Character. Aggregation used compute PU-level values rasters. One \"sum\" \"mean\". align_rasters Logical. TRUE, attempt align effect rasters PU raster grid zonal operations (default TRUE). keep_zero Logical. TRUE, keep rows benefit == 0 loss == 0. Default FALSE. drop_locked_out Logical. TRUE, drop rows (pu, action) pairs status == 3 x$data$dist_actions (column exists). Default TRUE. na_to_zero Logical. TRUE, treat missing values 0 computing benefit/loss. Default TRUE.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_losses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add losses (negative effects magnitude) — add_losses","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_absolute.html","id":null,"dir":"Reference","previous_headings":"","what":"Add mixed total targets (absolute) — add_mixed_targets_total_absolute","title":"Add mixed total targets (absolute) — add_mixed_targets_total_absolute","text":"Adds absolute mixed-total targets per feature. mixed-total target enforces baseline representation plus action-induced deltas jointly reach single threshold: $$\\sum_i z_{} r_{} + \\sum_{,} x_{ia}\\Delta_{ias} \\ge T^{mix}_s.$$","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_absolute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add mixed total targets (absolute) — add_mixed_targets_total_absolute","text":"","code":"add_mixed_targets_total_absolute(x, targets, overwrite = FALSE, label = NULL)"},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_absolute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add mixed total targets (absolute) — add_mixed_targets_total_absolute","text":"x data object. targets Target specification (absolute). See Targets format targets details. overwrite Logical. TRUE, replace existing mixed-total targets features (still errors conservation/recovery targets exist features). label Optional character label stored targets.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_absolute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add mixed total targets (absolute) — add_mixed_targets_total_absolute","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_absolute.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add mixed total targets (absolute) — add_mixed_targets_total_absolute","text":"Mixed-total targets conceptually different specifying separate conservation recovery targets feature. , mixed-total targets intended mutually exclusive conservation/recovery targets feature. Conflict checks handled .pa_store_targets().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_relative.html","id":null,"dir":"Reference","previous_headings":"","what":"Add mixed total targets (relative to baseline) — add_mixed_targets_total_relative","title":"Add mixed total targets (relative to baseline) — add_mixed_targets_total_relative","text":"Adds relative mixed-total targets proportions \\([0,1]\\) baseline totals per feature. Baseline totals computed via .pa_feature_totals() stored basis_total.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_relative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add mixed total targets (relative to baseline) — add_mixed_targets_total_relative","text":"","code":"add_mixed_targets_total_relative(x, targets, overwrite = FALSE, label = NULL)"},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_relative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add mixed total targets (relative to baseline) — add_mixed_targets_total_relative","text":"x data object. targets Target specification (proportions \\([0,1]\\)). overwrite Logical. TRUE, replace existing mixed-total targets features (subject mutual exclusivity rules enforced .pa_store_targets()). label Optional character label stored targets.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_mixed_targets_total_relative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add mixed total targets (relative to baseline) — add_mixed_targets_total_relative","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_benefit.html","id":null,"dir":"Reference","previous_headings":"","what":"Add objective: maximize benefit — add_objective_max_benefit","title":"Add objective: maximize benefit — add_objective_max_benefit","text":"Specify objective maximizes total benefit delivered selected actions. Benefit values taken benefit table produced add_benefits (stored x$data$dist_benefit /model-ready variant). function data-: stores objective specification inside Data object can materialized later optimization model built (typically calling solve()). alias provided, objective also registered x$data$objectives atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_benefit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add objective: maximize benefit — add_objective_max_benefit","text":"","code":"add_objective_max_benefit(x, benefit_col = \"benefit\", alias = NULL)"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_benefit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add objective: maximize benefit — add_objective_max_benefit","text":"x Data object created inputData inputDataSpatial. benefit_col Character. Column name model-ready benefit table containing numeric benefits. Default \"benefit\". alias Character scalar NULL. Optional identifier register objective atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_benefit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add objective: maximize benefit — add_objective_max_benefit","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_benefit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add objective: maximize benefit — add_objective_max_benefit","text":"function updates x$data$model_args : model_type \"maximizeBenefits\" objective_id \"max_benefit\" objective_args list benefit_col model builder require benefit data exist error benefits missing. another objective setter called afterwards, overwrites active single-objective specification x$data$model_args.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_benefit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add objective: maximize benefit — add_objective_max_benefit","text":"","code":"if (FALSE) { # \\dontrun{ x <- inputDataSpatial(pu = pu_sf, cost = \"cost\", features = feat_sf, pu_id_col = \"id\") |>   add_actions(actions_df) |>   add_benefits(benefits_df) |>   add_objective_max_benefit(alias = \"benefit\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_net_profit.html","id":null,"dir":"Reference","previous_headings":"","what":"Add objective: maximize net profit — add_objective_max_net_profit","title":"Add objective: maximize net profit — add_objective_max_net_profit","text":"Specify objective maximizes net profit, defined total profit selected (pu, action) pairs minus total costs: $$\\sum \\mathrm{profit}\\,x \\;-\\; \\left(\\sum \\mathrm{pu\\_cost}\\,w + \\sum \\mathrm{action\\_cost}\\,x\\right).$$ Profit taken x$data$dist_profit (created add_profit). Planning-unit costs taken x$data$pu; action costs taken x$data$dist_actions. function data-: stores objective specification inside Data object can materialized later optimization model built. alias provided, objective also registered x$data$objectives atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_net_profit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add objective: maximize net profit — add_objective_max_net_profit","text":"","code":"add_objective_max_net_profit(   x,   profit_col = \"profit\",   include_pu_cost = TRUE,   include_action_cost = TRUE,   alias = NULL )"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_net_profit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add objective: maximize net profit — add_objective_max_net_profit","text":"x Data object created inputData inputDataSpatial. profit_col Character. Column name x$data$dist_profit containing numeric profits. Default \"profit\". include_pu_cost Logical. TRUE, subtract planning-unit costs. include_action_cost Logical. TRUE, subtract action costs. alias Character scalar NULL. Optional identifier register objective atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_net_profit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add objective: maximize net profit — add_objective_max_net_profit","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_net_profit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add objective: maximize net profit — add_objective_max_net_profit","text":"function updates x$data$model_args : model_type \"maximizeNetProfit\" objective_id \"max_net_profit\" objective_args list profit_col, include_pu_cost, include_action_cost another objective setter called afterwards, overwrites active single-objective specification x$data$model_args.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_profit.html","id":null,"dir":"Reference","previous_headings":"","what":"Add objective: maximize profit — add_objective_max_profit","title":"Add objective: maximize profit — add_objective_max_profit","text":"Specify objective maximizes economic profit selected (pu, action) pairs. Profit values taken x$data$dist_profit, typically created add_profit. function data-: stores objective specification inside Data object can materialized later optimization model built (typically calling solve()). alias provided, objective also registered x$data$objectives atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_profit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add objective: maximize profit — add_objective_max_profit","text":"","code":"add_objective_max_profit(x, profit_col = \"profit\", alias = NULL)"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_profit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add objective: maximize profit — add_objective_max_profit","text":"x Data object created inputData inputDataSpatial. profit_col Character. Column name x$data$dist_profit containing numeric profits. Default \"profit\". alias Character scalar NULL. Optional identifier register objective atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_profit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add objective: maximize profit — add_objective_max_profit","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_max_profit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add objective: maximize profit — add_objective_max_profit","text":"function updates x$data$model_args : model_type \"maximizeProfit\" objective_id \"max_profit\" objective_args list profit_col another objective setter called afterwards, overwrites active single-objective specification x$data$model_args.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_action_fragmentation.html","id":null,"dir":"Reference","previous_headings":"","what":"Add objective: minimize action fragmentation — add_objective_min_action_fragmentation","title":"Add objective: minimize action fragmentation — add_objective_min_action_fragmentation","text":"Specify objective minimizes fragmentation action level spatial relation. objective intended models action allocations (rather PU selection) drive spatial cohesion. function data-: stores objective specification inside Data object can materialized later optimization model built. alias provided, objective also registered x$data$objectives atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_action_fragmentation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add objective: minimize action fragmentation — add_objective_min_action_fragmentation","text":"","code":"add_objective_min_action_fragmentation(   x,   relation_name = \"boundary\",   weight_multiplier = 1,   action_weights = NULL,   actions = NULL,   alias = NULL )"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_action_fragmentation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add objective: minimize action fragmentation — add_objective_min_action_fragmentation","text":"x Data object created inputData inputDataSpatial. relation_name Character. Name spatial relation x$data$spatial_relations. weight_multiplier Numeric \\(\\ge 0\\). Multiplier applied relation weights. Default 1. action_weights Optional action weights. Either named numeric vector (names = action ids) data.frame(action, weight). actions Optional subset action ids include objective. alias Character scalar NULL. Optional identifier register objective atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_action_fragmentation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add objective: minimize action fragmentation — add_objective_min_action_fragmentation","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_action_fragmentation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add objective: minimize action fragmentation — add_objective_min_action_fragmentation","text":"Action-level fragmentation can optionally weight actions differently via action_weights can optionally restrict objective subset actions via actions. exact linearization interpretation implemented model builder.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Register an atomic objective (internal) — add_objective_min_cost","title":"Register an atomic objective (internal) — add_objective_min_cost","text":"Internal helper used objective setter functions optionally register objective atomic objective multi-objective workflows. alias non-NULL, objective definition stored x$data$objectives[[alias]]. allows external multi-objective orchestration (e.g., weighted sum, \\(\\epsilon\\)-constraint, AUGMECON, interactive methods) refer objectives stable user-facing identifier. function fully backward compatible single-objective workflows: alias NULL, entry added x$data$objectives active single-objective specification stored x$data$model_args (set calling objective setter) used. Specify objective minimizes total costs associated solution. Costs may include planning-unit costs /action costs depending flags provided. function data-: stores objective specification inside Data object can materialized later optimization model built (typically calling solve()). alias provided, objective also registered x$data$objectives atomic objective multi-objective workflows, preserving legacy single-objective behavior (recently set objective remains active one x$data$model_args).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register an atomic objective (internal) — add_objective_min_cost","text":"","code":"add_objective_min_cost(   x,   include_pu_cost = TRUE,   include_action_cost = TRUE,   alias = NULL )"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_cost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register an atomic objective (internal) — add_objective_min_cost","text":"x Data object created inputData inputDataSpatial. include_pu_cost Logical. TRUE, include planning-unit costs objective. include_action_cost Logical. TRUE, include action costs objective. alias Character scalar NULL. Optional identifier register objective atomic objective multi-objective workflows. objective_id Character. Stable objective identifier (e.g., \"min_cost\"). model_type Character. Model type label used model builder (e.g., \"minimizeCosts\"). objective_args List. Objective-specific arguments stored objective. sense Character. Either \"min\" \"max\".","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_cost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register an atomic objective (internal) — add_objective_min_cost","text":"updated Data object. updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_cost.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register an atomic objective (internal) — add_objective_min_cost","text":"function updates x$data$model_args : model_type \"minimizeCosts\" objective_id \"min_cost\" objective_args list include_pu_cost include_action_cost model builder must interpret fields set objective coefficients.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_cost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Register an atomic objective (internal) — add_objective_min_cost","text":"","code":"if (FALSE) { # \\dontrun{ x <- inputDataSpatial(pu = pu_sf, cost = \"cost\", features = feat_sf, pu_id_col = \"id\") |>   add_actions(actions_df) |>   add_objective_min_cost()  # Register as atomic objective for multi-objective workflows x <- x |> add_objective_min_cost(alias = \"cost\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_fragmentation.html","id":null,"dir":"Reference","previous_headings":"","what":"Add objective: minimize fragmentation (PU cut) — add_objective_min_fragmentation","title":"Add objective: minimize fragmentation (PU cut) — add_objective_min_fragmentation","text":"Specify objective minimizes spatial fragmentation measured weighted cut selected non-selected planning units spatial relation: $$\\sum_{(,j)} w_{ij}\\,|z_i - z_j|.$$ model builder, objective linearized using auxiliary edge variables. Relation weights \\(w_{ij}\\) read x$data$spatial_relations[[relation_name]] can scaled weight_multiplier (BLM-like scaling). function data-: stores objective specification inside Data object can materialized later optimization model built. alias provided, objective also registered x$data$objectives atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_fragmentation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add objective: minimize fragmentation (PU cut) — add_objective_min_fragmentation","text":"","code":"add_objective_min_fragmentation(   x,   relation_name = \"boundary\",   weight_multiplier = 1,   alias = NULL )"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_fragmentation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add objective: minimize fragmentation (PU cut) — add_objective_min_fragmentation","text":"x Data object created inputData inputDataSpatial. relation_name Character. Name spatial relation x$data$spatial_relations (e.g., \"boundary\", \"rook\", \"queen\", \"knn\"). Default \"boundary\". weight_multiplier Numeric \\(\\ge 0\\). Multiplier applied relation weights. Default 1. alias Character scalar NULL. Optional identifier register objective atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_fragmentation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add objective: minimize fragmentation (PU cut) — add_objective_min_fragmentation","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_intervention_fragmentation.html","id":null,"dir":"Reference","previous_headings":"","what":"Add objective: minimize intervention fragmentation — add_objective_min_intervention_fragmentation","title":"Add objective: minimize intervention fragmentation — add_objective_min_intervention_fragmentation","text":"Specify objective minimizes fragmentation intervention level spatial relation. objective intended models interventions represent coarser grouping actions, spatial cohesion evaluated grouping level. function data-: stores objective specification inside Data object can materialized later optimization model built. alias provided, objective also registered x$data$objectives atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_intervention_fragmentation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add objective: minimize intervention fragmentation — add_objective_min_intervention_fragmentation","text":"","code":"add_objective_min_intervention_fragmentation(   x,   relation_name = \"boundary\",   weight_multiplier = 1,   alias = NULL )"},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_intervention_fragmentation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add objective: minimize intervention fragmentation — add_objective_min_intervention_fragmentation","text":"x Data object created inputData inputDataSpatial. relation_name Character. Name spatial relation x$data$spatial_relations. weight_multiplier Numeric \\(\\ge 0\\). Multiplier applied relation weights. Default 1. alias Character scalar NULL. Optional identifier register objective atomic objective multi-objective workflows.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_objective_min_intervention_fragmentation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add objective: minimize intervention fragmentation — add_objective_min_intervention_fragmentation","text":"updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_profit.html","id":null,"dir":"Reference","previous_headings":"","what":"Add profit to a planning problem — add_profit","title":"Add profit to a planning problem — add_profit","text":"Define (economic) profit values feasible (pu, action) pairs store x$data$dist_profit. Profit intentionally stored separately ecological benefit/loss (see add_effects / add_benefits).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_profit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add profit to a planning problem — add_profit","text":"","code":"add_profit(x, profit = NULL, keep_zero = FALSE, na_to_zero = TRUE)"},{"path":"https://josesalgr.github.io/mosap/reference/add_profit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add profit to a planning problem — add_profit","text":"x Data object created inputData inputDataSpatial. Must contain x$data$dist_actions x$data$actions (run add_actions first). profit Profit specification. One : NULL: profit set 0 feasible (pu, action) pairs. numeric scalar: recycled feasible (pu, action) pairs. named numeric vector: names action ids; assigns global profit per action. data.frame(action, profit): assigns global profit per action. data.frame(pu, action, profit): assigns explicit profit values pair. keep_zero Logical. TRUE, keep rows profit == 0 stored table. Default FALSE (zero-profit rows dropped). na_to_zero Logical. TRUE, treat missing profit values 0 joins/matching. Default TRUE.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_profit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add profit to a planning problem — add_profit","text":"updated Data object x$data$dist_profit created/updated.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_profit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add profit to a planning problem — add_profit","text":"function creates profit table aligned current feasibility table x$data$dist_actions. resulting x$data$dist_profit contains: pu: external planning unit id, action: action id, profit: numeric profit value, internal_pu: internal PU index, internal_action: internal action index. Profit values can later used build objectives (e.g., maximize profit maximize net profit), budget constraints (e.g., net cost = cost - profit), reporting summaries. function data-: build modify optimization model. also change feasibility; simply assigns profits rows currently present dist_actions. additional filtering (e.g., dropping locked-pairs) applied preparing model-ready tables (typically inside model builder invoked solve()).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_profit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add profit to a planning problem — add_profit","text":"","code":"if (FALSE) { # \\dontrun{ # 1) Default: profit = 0 everywhere (table may be empty if keep_zero = FALSE) x <- x |> add_profit()  # 2) Constant profit for every feasible (pu, action) x <- x |> add_profit(profit = 10)  # 3) Profit per action (named vector) pr <- c(harvest = 50, sustainable = 20, restoration = -5) x <- x |> add_profit(profit = pr)  # 4) Profit per action (data.frame) pr_df <- data.frame(action = c(\"harvest\", \"sustainable\"), profit = c(50, 20)) x <- x |> add_profit(profit = pr_df)  # 5) Profit per (pu, action) pair pr_sp <- data.frame(   pu = c(1, 2, 2),   action = c(\"harvest\", \"harvest\", \"sustainable\"),   profit = c(100, 80, 30) ) x <- x |> add_profit(profit = pr_sp, keep_zero = TRUE) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_absolute.html","id":null,"dir":"Reference","previous_headings":"","what":"Add recovery targets (absolute) — add_recovery_targets_absolute","title":"Add recovery targets (absolute) — add_recovery_targets_absolute","text":"Adds absolute recovery targets per feature. Recovery targets represent thresholds action-driven improvements (deltas) rather baseline representation. provided values treated absolute thresholds units effect/benefit amounts used model builder.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_absolute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add recovery targets (absolute) — add_recovery_targets_absolute","text":"","code":"add_recovery_targets_absolute(x, targets, overwrite = FALSE, label = NULL)"},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_absolute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add recovery targets (absolute) — add_recovery_targets_absolute","text":"x data object. targets Target specification. See Targets format targets details. overwrite Logical. TRUE, replace existing recovery targets features. label Optional character label stored targets.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_absolute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add recovery targets (absolute) — add_recovery_targets_absolute","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_relative.html","id":null,"dir":"Reference","previous_headings":"","what":"Add recovery targets (relative) — add_recovery_targets_relative","title":"Add recovery targets (relative) — add_recovery_targets_relative","text":"Adds relative recovery targets proportions \\([0,1]\\) per-feature basis. default, basis potential maximum improvement per feature derived available actions (via .pa_feature_potential()). Alternatively, relative_basis=\"baseline\" uses baseline totals (via .pa_feature_totals()).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_relative.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add recovery targets (relative) — add_recovery_targets_relative","text":"","code":"add_recovery_targets_relative(   x,   targets,   relative_basis = c(\"potential\", \"baseline\"),   overwrite = FALSE,   label = NULL )"},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_relative.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add recovery targets (relative) — add_recovery_targets_relative","text":"x data object. targets Target specification (proportions \\([0,1]\\)). relative_basis Character. Basis used convert relative targets absolute thresholds: \"potential\" (default) \"baseline\". overwrite Logical. TRUE, replace existing recovery targets features. label Optional character label stored targets.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_recovery_targets_relative.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add recovery targets (relative) — add_recovery_targets_relative","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_boundary.html","id":null,"dir":"Reference","previous_headings":"","what":"Add spatial boundary-length relations from sf polygons or a boundary table — add_spatial_boundary","title":"Add spatial boundary-length relations from sf polygons or a boundary table — add_spatial_boundary","text":"Register boundary-length relation planning units. Boundary relations represent shared edge length adjacent polygons (queen touches).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_boundary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add spatial boundary-length relations from sf polygons or a boundary table — add_spatial_boundary","text":"","code":"add_spatial_boundary(   x,   boundary = NULL,   pu_sf = NULL,   name = \"boundary\",   weight_col = NULL,   weight_multiplier = 1,   progress = FALSE,   include_self = TRUE,   edge_factor = 1 )"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_boundary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add spatial boundary-length relations from sf polygons or a boundary table — add_spatial_boundary","text":"x data object. boundary Optional data.frame describing boundaries. Accepted formats: (id1, id2, boundary) (Marxan-style), (pu1, pu2, weight). pu_sf Optional sf object PU polygons id column. NULL, uses x$data$pu_sf. name Character name/key store relation (default \"boundary\"). weight_col Character. Column boundary use weights. NULL, attempts guess \"boundary\" \"weight\". weight_multiplier Numeric multiplier applied boundary weights (e.g., BLM scaling). Must finite positive. progress Logical. TRUE, prints basic progress messages large instances. include_self Logical. TRUE (default), include diagonal (,) entries representing effective exposed boundary length. edge_factor Numeric \\(\\ge 0\\). Multiplier applied exposed boundary computing diagonal weights.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_boundary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add spatial boundary-length relations from sf polygons or a boundary table — add_spatial_boundary","text":"Updated data object stored relation x$data$spatial_relations[[name]].","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_boundary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add spatial boundary-length relations from sf polygons or a boundary table — add_spatial_boundary","text":"Two input modes supported: Boundary table mode. boundary provided, interpreted table containing PU pairs boundary-length weight (e.g., Marxan-style bound.dat). Geometry mode. boundary NULL, boundary lengths derived planning-unit polygons (pu_sf x$data$pu_sf). include_self=TRUE, function also adds diagonal entries (,) weights equal \"effective exposed boundary\" (scaled edge_factor). useful objectives boundary-length modifier / fragmentation penalties perimeter exposed outside counted.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_boundary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add spatial boundary-length relations from sf polygons or a boundary table — add_spatial_boundary","text":"","code":"if (FALSE) { # \\dontrun{ # From a Marxan-style boundary table: x <- x |> add_spatial_boundary(boundary = bound_df, name = \"boundary\")  # From sf polygons: x <- x |> add_spatial_boundary(pu_sf = pu_sf, include_self = TRUE, edge_factor = 1) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Add distance-threshold spatial relations from coordinates — add_spatial_distance","title":"Add distance-threshold spatial relations from coordinates — add_spatial_distance","text":"Build register edges planning units whose Euclidean distance less equal dmax, based coordinates. constructor require sf.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add distance-threshold spatial relations from coordinates — add_spatial_distance","text":"","code":"add_spatial_distance(   x,   coords = NULL,   dmax,   name = \"default\",   weight_fn = c(\"constant\", \"inverse\", \"inverse_sq\"),   eps = 1e-09 )"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add distance-threshold spatial relations from coordinates — add_spatial_distance","text":"x data object created inputData() inputDataSpatial(). coords Optional coordinates specification (see add_spatial_knn). dmax Numeric. Maximum distance edge (must finite positive). name Character name/key store relation. weight_fn Character. convert distance weight: \"constant\", \"inverse\", \"inverse_sq\". eps Small numeric constant avoid division zero using inverse weights.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add distance-threshold spatial relations from coordinates — add_spatial_distance","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_distance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add distance-threshold spatial relations from coordinates — add_spatial_distance","text":"constructor uses \\(O(n^2)\\) distance computation therefore best suited small moderate numbers planning units. large instances, consider add_spatial_knn instead.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add distance-threshold spatial relations from coordinates — add_spatial_distance","text":"","code":"if (FALSE) { # \\dontrun{ x <- x |> add_spatial_distance(dmax = 1000, name = \"within_1km\", weight_fn = \"constant\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_knn.html","id":null,"dir":"Reference","previous_headings":"","what":"Add k-nearest-neighbours spatial relations from coordinates — add_spatial_knn","title":"Add k-nearest-neighbours spatial relations from coordinates — add_spatial_knn","text":"Build register k-nearest-neighbours (kNN) graph planning units based coordinates. constructor require sf. RANN package available, used speed.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_knn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add k-nearest-neighbours spatial relations from coordinates — add_spatial_knn","text":"","code":"add_spatial_knn(   x,   coords = NULL,   k = 8,   name = \"default\",   weight_fn = c(\"constant\", \"inverse\", \"inverse_sq\"),   eps = 1e-09 )"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_knn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add k-nearest-neighbours spatial relations from coordinates — add_spatial_knn","text":"x data object created inputData() inputDataSpatial(). coords Optional coordinates specification: data.frame(id, x, y), matrix two columns (x,y) aligned PU order. NULL, uses x$data$pu_coords x$data$pu$x/y. k Integer. Number neighbours per planning unit (must >= 1 < n_pu). name Character name/key store relation. weight_fn Character. convert distance weight: \"constant\", \"inverse\", \"inverse_sq\". eps Small numeric constant avoid division zero using inverse weights.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_knn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add k-nearest-neighbours spatial relations from coordinates — add_spatial_knn","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_knn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add k-nearest-neighbours spatial relations from coordinates — add_spatial_knn","text":"Coordinates can supplied explicitly via coords, stored x$data$pu_coords, stored columns x$data$pu$x x$data$pu$y. Edge weights can constant derived distance using weight_fn. stored relation undirected default (duplicates collapsed).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_knn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add k-nearest-neighbours spatial relations from coordinates — add_spatial_knn","text":"","code":"if (FALSE) { # \\dontrun{ x <- x |> add_spatial_knn(k = 8, name = \"knn8\", weight_fn = \"inverse\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_queen.html","id":null,"dir":"Reference","previous_headings":"","what":"Add queen adjacency from sf polygons — add_spatial_queen","title":"Add queen adjacency from sf polygons — add_spatial_queen","text":"Build register queen adjacency relation (shared edge shared vertex) planning-unit polygons. Queen adjacency includes rook neighbours plus corner-touching neighbours.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_queen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add queen adjacency from sf polygons — add_spatial_queen","text":"","code":"add_spatial_queen(x, pu_sf = NULL, name = \"default\", weight = 1)"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_queen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add queen adjacency from sf polygons — add_spatial_queen","text":"x data object created inputDataSpatial(). pu_sf Optional sf object PU polygons id column. NULL, uses x$data$pu_sf. name Character name/key store relation. weight Numeric edge weight assigned queen adjacency (default 1).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_queen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add queen adjacency from sf polygons — add_spatial_queen","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_queen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add queen adjacency from sf polygons — add_spatial_queen","text":"","code":"if (FALSE) { # \\dontrun{ x <- x |> add_spatial_queen(name = \"queen\", weight = 1) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_relations.html","id":null,"dir":"Reference","previous_headings":"","what":"Add spatial relations (core) — add_spatial_relations","title":"Add spatial relations (core) — add_spatial_relations","text":"Register externally computed spatial relation inside Data object using unified internal representation. users prefer convenience wrappers: add_spatial_boundary, add_spatial_rook, add_spatial_queen, add_spatial_knn, add_spatial_distance.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_relations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add spatial relations (core) — add_spatial_relations","text":"","code":"add_spatial_relations(   x,   relations,   name = \"default\",   directed = FALSE,   allow_self = FALSE,   duplicate_agg = c(\"sum\", \"max\", \"min\", \"mean\"),   symmetric = FALSE )"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_relations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add spatial relations (core) — add_spatial_relations","text":"x data object created inputData() inputDataSpatial(). relations data.frame describing edges. Must contain either: pu1, pu2, weight (external PU ids), internal_pu1, internal_pu2, weight (internal indices). Extra columns (e.g., distance, source) allowed preserved possible. name Character. Name/key store relation (default \"default\"). directed Logical. FALSE (default), treats edges undirected collapses duplicates. TRUE, keeps directed edges provided. allow_self Logical. Whether allow self-edges (,). Default FALSE. duplicate_agg Aggregation duplicate undirected edges directed=FALSE. One \"sum\", \"max\", \"min\", \"mean\". symmetric Logical. TRUE, expands undirected relation directed one duplicating -diagonal edges directions. Default FALSE.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_relations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add spatial relations (core) — add_spatial_relations","text":"Updated data object x$data$spatial_relations[[name]].","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_relations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add spatial relations (core) — add_spatial_relations","text":"input can given external PU ids (pu1, pu2) internal PU indices (internal_pu1, internal_pu2). external ids provided, mapped using x$data$pu$id x$data$pu$internal_id. directed = FALSE, edges treated undirected duplicates collapsed using duplicate_agg. symmetric = TRUE, relation expanded directed edge list adding swapped copies -diagonal edges.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_relations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add spatial relations (core) — add_spatial_relations","text":"","code":"if (FALSE) { # \\dontrun{ # Register an externally computed adjacency list: rel <- data.frame(pu1 = c(1, 1, 2), pu2 = c(2, 3, 3), weight = 1) x <- x |> add_spatial_relations(relations = rel, name = \"my_adj\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_rook.html","id":null,"dir":"Reference","previous_headings":"","what":"Add rook adjacency from sf polygons — add_spatial_rook","title":"Add rook adjacency from sf polygons — add_spatial_rook","text":"Build register rook adjacency relation (shared edge) planning-unit polygons. Rook adjacency detects pairs polygons share non-zero-length boundary segment.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_rook.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add rook adjacency from sf polygons — add_spatial_rook","text":"","code":"add_spatial_rook(x, pu_sf = NULL, name = \"default\", weight = 1)"},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_rook.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add rook adjacency from sf polygons — add_spatial_rook","text":"x data object created inputDataSpatial(). pu_sf Optional sf object PU polygons id column. NULL, uses x$data$pu_sf. name Character name/key store relation. weight Numeric edge weight assigned rook adjacency (default 1).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_rook.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add rook adjacency from sf polygons — add_spatial_rook","text":"Updated data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/add_spatial_rook.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add rook adjacency from sf polygons — add_spatial_rook","text":"","code":"if (FALSE) { # \\dontrun{ x <- x |> add_spatial_rook(name = \"rook\", weight = 1) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/as_mo_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a multi-objective problem wrapper — as_mo_problem","title":"Create a multi-objective problem wrapper — as_mo_problem","text":"Create multi-objective problem wrapper","code":""},{"path":"https://josesalgr.github.io/mosap/reference/as_mo_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a multi-objective problem wrapper — as_mo_problem","text":"","code":"as_mo_problem(x)"},{"path":"https://josesalgr.github.io/mosap/reference/as_mo_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a multi-objective problem wrapper — as_mo_problem","text":"x Data object created prioriactions::inputData() (compatible object).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/as_mo_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a multi-objective problem wrapper — as_mo_problem","text":"object class MOProblem.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/data-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Data class — data-class","title":"Data class — data-class","text":"Data class core container used prioriactions store information required define solve multi-action planning problem. holds planning-unit table, feature threat catalogues, action definitions distributions (feasibility, costs, effects), optional spatial inputs (sf geometry, coordinate tables, spatial relations), (optionally) built optimization model snapshot. Objects class typically created inputData() inputDataSpatial(). Downstream functions (e.g., add_actions(), add_effects(), target setters, objectives) enrich internal data list adding updating relevant tables.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/data-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data class — data-class","text":"return value (class definition).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/data-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data class — data-class","text":"Data class designed support legacy single-objective workflows newer modular/multi-objective workflows. Many functions operate \"data-first\" way: store specifications (e.g., targets, objectives, constraints) x$data optimization model built later (typically calling solve()).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/data-class.html","id":"storage","dir":"Reference","previous_headings":"","what":"Storage","title":"Data class — data-class","text":"class contains single field: data named list holding tables metadata used workflow. Common elements include pu, features, threats, actions, dist_features, dist_actions, dist_effects/dist_benefit, pu_sf, pu_coords, spatial_relations, targets, model-related entries model_ptr, model_list, model_args.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/data-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Data class — data-class","text":"print() Print concise summary stored data , present, basic information built optimization model (dimensions, objective type, auxiliary variables fragmentation variables). Uses cli available, otherwise falls back plain-text summary. show() Alias print(). repr() Returns short string representation. getData(name) Retrieve element stored data name. getPlanningUnitsAmount() Return number planning units stored x$data$pu. getMonitoringCosts() Return planning-unit cost vector. Prefers column cost x$data$pu falls back legacy monitoring_cost present. getFeatureAmount() Return number features stored x$data$features. getFeatureNames() Return feature names x$data$features$name. getThreatsAmount() Return number threats stored x$data$threats. getThreatNames() Return threat names x$data$threats$name. getActionCosts() Return action costs. Prefers model-ready action table x$data$dist_actions$cost; otherwise falls back legacy x$data$dist_threats$action_cost. getActionsAmount() Return number actions. Prefers x$data$actions (new API); otherwise falls back number rows legacy x$data$dist_threats.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/dot-pa_build_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Build optimization model from Data — .pa_build_model","title":"Build optimization model from Data — .pa_build_model","text":"Materializes (builds) optimization model using current state Data object: prepared data tables, stored objective settings, stored constraints (e.g., targets).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/dot-pa_build_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build optimization model from Data — .pa_build_model","text":"","code":".pa_build_model(x)"},{"path":"https://josesalgr.github.io/mosap/reference/dot-pa_build_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build optimization model from Data — .pa_build_model","text":"x Data object (class \"Data\") created inputData()/inputDataSpatial().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/dot-pa_build_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build optimization model from Data — .pa_build_model","text":"Updated Data object model pointer model snapshot.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_actions.html","id":null,"dir":"Reference","previous_headings":"","what":"Get action results from a Solution — get_actions","title":"Get action results from a Solution — get_actions","text":"Extract action-allocation results table solution object returned solve(). returned table includes selected indicator (typically 0/1) showing whether feasible (pu, action) pair selected solution.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_actions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get action results from a Solution — get_actions","text":"","code":"get_actions(x, only_selected = FALSE)"},{"path":"https://josesalgr.github.io/mosap/reference/get_actions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get action results from a Solution — get_actions","text":"x solution object returned solve(). only_selected Logical. TRUE, return rows selected == 1. Default FALSE.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_actions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get action results from a Solution — get_actions","text":"data.frame action-allocation information stored solution selected column.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_actions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get action results from a Solution — get_actions","text":"function expects solution object store action-allocation table x$data$tables$actions. errors table missing. only_selected = TRUE, also errors selected column present.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/get_actions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get action results from a Solution — get_actions","text":"","code":"if (FALSE) { # \\dontrun{ sol <- solve(problem) act_tbl <- get_actions(sol) act_sel <- get_actions(sol, only_selected = TRUE) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/get_features.html","id":null,"dir":"Reference","previous_headings":"","what":"Get feature achievement summary from a Solution — get_features","title":"Get feature achievement summary from a Solution — get_features","text":"Extract feature achievement table solution object returned solve(). table typically summarizes, feature, much achieved baseline selection action effects, total.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_features.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get feature achievement summary from a Solution — get_features","text":"","code":"get_features(x)"},{"path":"https://josesalgr.github.io/mosap/reference/get_features.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get feature achievement summary from a Solution — get_features","text":"x solution object returned solve().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_features.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get feature achievement summary from a Solution — get_features","text":"data.frame feature achievement metrics stored solution.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_features.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get feature achievement summary from a Solution — get_features","text":"function expects feature achievement table x$data$tables$features errors missing. exact columns depend model reporting options, commonly include: baseline_contrib: contribution baseline / conservation selection. recovery_contrib: contribution action effects (e.g., benefits). total: baseline + recovery.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/get_features.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get feature achievement summary from a Solution — get_features","text":"","code":"if (FALSE) { # \\dontrun{ sol <- solve(problem) feat_tbl <- get_features(sol) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/get_pu.html","id":null,"dir":"Reference","previous_headings":"","what":"Get planning unit results from a Solution — get_pu","title":"Get planning unit results from a Solution — get_pu","text":"Extract planning-unit results table solution object returned solve(). returned table includes selected indicator (typically 0/1) showing whether planning unit selected solution.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_pu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get planning unit results from a Solution — get_pu","text":"","code":"get_pu(x, only_selected = FALSE)"},{"path":"https://josesalgr.github.io/mosap/reference/get_pu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get planning unit results from a Solution — get_pu","text":"x solution object returned solve(). only_selected Logical. TRUE, return rows selected == 1. Default FALSE.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_pu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get planning unit results from a Solution — get_pu","text":"data.frame planning-unit information stored solution selected column.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_pu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get planning unit results from a Solution — get_pu","text":"function expects solution object store planning-unit results table x$data$tables$pu. errors table missing. only_selected = TRUE, also errors selected column present.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/get_pu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get planning unit results from a Solution — get_pu","text":"","code":"if (FALSE) { # \\dontrun{ sol <- solve(problem) pu_tbl <- get_pu(sol) pu_sel <- get_pu(sol, only_selected = TRUE) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/get_solution_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Get raw solution vector from a Solution — get_solution_vector","title":"Get raw solution vector from a Solution — get_solution_vector","text":"Return raw decision-variable vector produced solver, internal model variable order used optimizer backend.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_solution_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get raw solution vector from a Solution — get_solution_vector","text":"","code":"get_solution_vector(x)"},{"path":"https://josesalgr.github.io/mosap/reference/get_solution_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get raw solution vector from a Solution — get_solution_vector","text":"x solution object returned solve().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_solution_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get raw solution vector from a Solution — get_solution_vector","text":"numeric vector one value per model variable.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_solution_vector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get raw solution vector from a Solution — get_solution_vector","text":"function expects raw solution vector x$data$sol errors missing. vector returned numeric corresponds model's variable ordering (e.g., planning-unit selection variables, action variables, auxiliary variables fragmentation variables present).","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/get_solution_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get raw solution vector from a Solution — get_solution_vector","text":"","code":"if (FALSE) { # \\dontrun{ sol <- solve(problem) v <- get_solution_vector(sol) length(v) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/get_targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Get target achievement table from a Solution — get_targets","title":"Get target achievement table from a Solution — get_targets","text":"Extract target achievement table (present) solution object returned solve(). targets table typically contains target value, achieved value, gap (achieved - target_value), plus target metadata type units.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_targets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get target achievement table from a Solution — get_targets","text":"","code":"get_targets(x)"},{"path":"https://josesalgr.github.io/mosap/reference/get_targets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get target achievement table from a Solution — get_targets","text":"x solution object returned solve().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_targets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get target achievement table from a Solution — get_targets","text":"data.frame target achievement metrics, NULL solution contain targets table.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/get_targets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get target achievement table from a Solution — get_targets","text":"Targets optional. solution include x$data$tables$targets, function returns NULL without error.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/get_targets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get target achievement table from a Solution — get_targets","text":"","code":"if (FALSE) { # \\dontrun{ sol <- solve(problem) tgt_tbl <- get_targets(sol) if (!is.null(tgt_tbl)) head(tgt_tbl) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/inputData.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a planning problem input object — inputData","title":"Create a planning problem input object — inputData","text":"Builds Data object either tabular inputs spatial inputs. entry point mosap workflow. function supports three input styles: Tabular mode: pu, features, dist_features data.frames, purely tabular workflow used (spatial packages required). Vector-PU spatial mode: dist_features missing (NULL) pu spatial vector (e.g. terra::SpatVector, sf, vector file path), features raster stack (one layer per feature), feature amounts aggregated polygon (default sum) stored dist_features. Raster-cell fast mode: dist_features missing (NULL) pu features rasters (e.g. terra::SpatRaster raster file paths), valid raster cell becomes planning unit. mode: cells valid cost finite cost > 0 pu used mask/template (cells NA pu excluded) avoids raster--polygon conversion substantially faster large grids.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/inputData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a planning problem input object — inputData","text":"","code":"inputData(   pu,   features,   dist_features,   cost = NULL,   pu_id_col = \"id\",   locked_in_col = \"locked_in\",   locked_out_col = \"locked_out\",   pu_status = NULL,   cost_aggregation = c(\"mean\", \"sum\"),   ... )  # S4 method for class 'data.frame,data.frame,data.frame' inputData(   pu,   features,   dist_features,   cost = NULL,   pu_id_col = \"id\",   locked_in_col = \"locked_in\",   locked_out_col = \"locked_out\",   pu_status = NULL,   cost_aggregation = c(\"mean\", \"sum\"),   ... )  # S4 method for class 'ANY,ANY,missing' inputData(   pu,   features,   dist_features,   cost = NULL,   pu_id_col = \"id\",   locked_in_col = \"locked_in\",   locked_out_col = \"locked_out\",   pu_status = NULL,   cost_aggregation = c(\"mean\", \"sum\"),   ... )  # S4 method for class 'ANY,ANY,NULL' inputData(   pu,   features,   dist_features,   cost = NULL,   pu_id_col = \"id\",   locked_in_col = \"locked_in\",   locked_out_col = \"locked_out\",   pu_status = NULL,   cost_aggregation = c(\"mean\", \"sum\"),   ... )"},{"path":"https://josesalgr.github.io/mosap/reference/inputData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a planning problem input object — inputData","text":"pu Planning units input. Either: data.frame id column (tabular mode), spatial vector (terra::SpatVector, sf, vector file path) (vector-PU mode), raster (terra::SpatRaster raster file path) used mask/template (raster-cell mode). features Features input. Either: data.frame id (optionally name) (tabular mode), raster stack one layer per feature (terra::SpatRaster file path) (vector-PU mode raster-cell mode). dist_features Distribution features. data.frame columns pu, feature, amount. missing NULL, spatial workflows derive automatically. cost spatial modes, required. Either column name PU vector attribute table (vector-PU mode) raster/file path (vector-PU raster-cell mode). raster-cell mode, cells cost <= 0 NA excluded (PU created). pu_id_col vector-PU mode, name id column PU layer. locked_in_col vector-PU mode, name logical column indicating locked-PUs. locked_out_col vector-PU mode, name logical column indicating locked-PUs. pu_status Optional (vector-PU raster-cell) status input. Either column name raster/file path. Values 2 mark locked-3 mark locked-(Marxan-style). cost_aggregation vector-PU mode, aggregate raster cell costs polygons cost raster. Either \"mean\" \"sum\". ... Additional arguments forwarded internal builders.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/inputData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a planning problem input object — inputData","text":"Data object used downstream functions (add_*(), set_solver(), solve(), etc.).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/inputData.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a planning problem input object — inputData","text":"Spatial relations created automatically. version inputData() take boundary argument. Spatial relations (boundary/rook/queen/kNN/distance) must registered explicitly inputData() using add_spatial_boundary(), add_spatial_rook(), add_spatial_queen(), add_spatial_knn(), add_spatial_distance(), add_spatial_relations(). raster-cell mode typically build relations coordinates add_spatial_knn() add_spatial_distance().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/inputData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a planning problem input object — inputData","text":"","code":"if (FALSE) { # \\dontrun{ # ------------------------------------------------------ # 1) Tabular mode # ------------------------------------------------------ pu <- data.frame(id = 1:3, cost = c(1, 2, 3)) features <- data.frame(id = 1:2, name = c(\"sp1\", \"sp2\")) dist_features <- data.frame(   pu = c(1, 1, 2, 3),   feature = c(1, 2, 2, 1),   amount = c(1, 5, 2, 1) )  x <- inputData(pu = pu, features = features, dist_features = dist_features)  # Optional: register a spatial relation later (if you need spatial objectives) rel <- data.frame(pu1 = 1, pu2 = 2, weight = 1) x <- add_spatial_relations(x, rel, name = \"rook_like\")   # ------------------------------------------------------ # 2) Raster-cell fast mode (1 PU per valid cell) # ------------------------------------------------------ library(terra) pu_mask <- rast(\"pu_mask.tif\")           # NA outside study area cost_r  <- rast(\"cost.tif\")              # cost per cell feat_r  <- rast(c(\"sp1.tif\", \"sp2.tif\")) # layers = features  x <- inputData(pu = pu_mask, features = feat_r, cost = cost_r)  # Optional: add spatial relations after inputData (e.g., kNN) x <- add_spatial_knn(x, k = 8, name = \"knn8\", weight_fn = \"inverse\")   # ------------------------------------------------------ # 3) Vector-PU spatial mode (polygons + raster features) # ------------------------------------------------------ pu_v   <- vect(\"pus.gpkg\")               # polygon PUs feat_r <- rast(c(\"sp1.tif\", \"sp2.tif\"))  # features as raster layers cost_r <- rast(\"cost.tif\")               # raster cost (aggregated to polygons)  x <- inputData(   pu = pu_v,   features = feat_r,   cost = cost_r,   pu_id_col = \"id\",   cost_aggregation = \"mean\" )  # Add boundary-length relation explicitly (requires sf) x <- add_spatial_boundary(x, pu_sf = x$data$pu_sf, name = \"boundary\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/inputDataSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a planning problem from spatial inputs — inputDataSpatial","title":"Create a planning problem from spatial inputs — inputDataSpatial","text":"Convert common spatial inputs (rasters vector layers Shapefiles GeoPackages) tabular inputs required inputData(). function builds base planning problem: planning units (pu), features, dist_features, optionally boundary. Actions action-benefits added later via add_actions() add_action_benefit(). Spatial backends optional (package import default). use function need: terra reading rasters/vectors extracting raster values. sf ask automatically derive boundary table.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/inputDataSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a planning problem from spatial inputs — inputDataSpatial","text":"","code":"inputDataSpatial(   pu,   features,   cost,   pu_id_col = \"id\",   locked_in_col = \"locked_in\",   locked_out_col = \"locked_out\",   pu_status = NULL,   cost_aggregation = c(\"mean\", \"sum\"),   boundary = \"auto\",   ... )"},{"path":"https://josesalgr.github.io/mosap/reference/inputDataSpatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a planning problem from spatial inputs — inputDataSpatial","text":"pu Planning units either: file path raster (e.g. GeoTIFF) cell values PU ids, terra::SpatRaster PU ids, file path vector layer (e.g. .shp, .gpkg), terra::SpatVector sf object column PU ids. features raster (file path) one layer per feature. Values interpreted amount per cell. Layer names used feature names. cost Either: column name pu (pu vector), raster (file path) providing cost per cell (pu raster pu lacks cost column). pu_id_col pu vector layer, name column containing planning unit ids. locked_in_col, locked_out_col Column names pu (vector) logical lock flags. missing, defaults FALSE. pu_status Optional. Either column name (pu vector) raster (file path) values 0,2,3 meaning available, locked-, locked-. converted locked_in/locked_out. column locks pu_status provided, column locks take precedence. cost_aggregation Aggregation used compute PU-level cost cost raster (default: mean). boundary Either NULL, data.frame columns id1, id2, boundary, string \"auto\" derive adjacency-based boundaries polygon planning units (boundary weight set 1 touching PU pairs). ... Passed inputData().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/inputDataSpatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a planning problem from spatial inputs — inputDataSpatial","text":"object created inputData().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mo-problem-class.html","id":null,"dir":"Reference","previous_headings":"","what":"MOProblem class — mo-problem-class","title":"MOProblem class — mo-problem-class","text":"container multi-objective optimization workflows built top prioriactions Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mo-problem-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"MOProblem class — mo-problem-class","text":"goal MOProblem keep prioriactions focused defining data, constraints atomic objectives, prioriactionsMO orchestrates multi-objective methods (weighted sum, epsilon-constraint, AUGMECON, goal programming, interactive, etc.). Conceptually, MOProblem wraps: base Data object (coming prioriactions::inputData()), registry atomic objectives (alias, direction builders), multi-objective \"method\" configuration (e.g., weights, epsilons), Results (solutions, objective values, solver logs).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mo-problem-class.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"MOProblem class — mo-problem-class","text":"data Data object prioriactions. objectives named list registered objectives (alias). method list describing selected multi-objective method parameters. results list storing solutions, objective values diagnostics. meta list bookkeeping (package versions, creation time, etc.).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mo-problem-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"MOProblem class — mo-problem-class","text":"print(): Print compact summary. show(): Alias print(). repr(): Short representation. getData(): Return underlying Data object. listObjectives(): Return objective aliases currently registered. getObjective(alias): Return objective definition alias.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mo-result-class.html","id":null,"dir":"Reference","previous_headings":"","what":"MOResult class — mo-result-class","title":"MOResult class — mo-result-class","text":"Container results produced multi-objective methods prioriactionsMO.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mo-result-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"MOResult class — mo-result-class","text":"MOResult stores: run table (one row per run/solution), list underlying single-objective prioriactions::Solution objects, Metadata (method config, call, timestamps, etc.).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mo-result-class.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"MOResult class — mo-result-class","text":"runs data.frame one row per run (weights/epsilons, status, runtime, gap, objective values, etc.). solutions list prioriactions::Solution objects (one per run). meta list method configuration, call, additional bookkeeping.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mosap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create and solve multi-actions planning problems — mosap","title":"Create and solve multi-actions planning problems — mosap","text":"Create solve multi-actions planning problem single call. convenience wrapper around:","code":"inputData() -> (optional: add_spatial_* relations) -> solve()"},{"path":"https://josesalgr.github.io/mosap/reference/mosap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create and solve multi-actions planning problems — mosap","text":"","code":"mosap(...)"},{"path":"https://josesalgr.github.io/mosap/reference/mosap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create and solve multi-actions planning problems — mosap","text":"... Arguments inherited inputData() solve(). addition, wrapper supports boundary described .","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mosap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create and solve multi-actions planning problems — mosap","text":"object class solution.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mosap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create and solve multi-actions planning problems — mosap","text":"problem(): wrapper call problem(). optimization model expected built solved solve() information stored Data object (objectives, targets, relations, etc.). Spatial relations / boundary: function pass boundary inputData(). provide boundary, interpreted request register spatial relation inputData() solve(). Supported boundary values: data.frame boundary table (e.g., columns id1,id2,boundary pu1,pu2,weight), registered via add_spatial_boundary(). \"auto\" derive boundary-length relations x$data$pu_sf (requires sf inputData() stored pu_sf).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/mosap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create and solve multi-actions planning problems — mosap","text":"","code":"# \\donttest{ set.seed(14)  data(sim_pu_data, sim_features_data, sim_dist_features_data,      sim_threats_data, sim_dist_threats_data, sim_sensitivity_data,      sim_boundary_data)  ## One-shot solve (tabular), registering a boundary relation from a table s <- mosap(   pu = sim_pu_data,   features = sim_features_data,   dist_features = sim_dist_features_data,   threats = sim_threats_data,   dist_threats = sim_dist_threats_data,   sensitivity = sim_sensitivity_data,   boundary = sim_boundary_data,   model_type = \"minimizeCosts\",   time_limit = 50,   output_file = FALSE,   cores = 2 ) #> Error in mosap(pu = sim_pu_data, features = sim_features_data, dist_features = sim_dist_features_data,     threats = sim_threats_data, dist_threats = sim_dist_threats_data,     sensitivity = sim_sensitivity_data, boundary = sim_boundary_data,     model_type = \"minimizeCosts\", time_limit = 50, output_file = FALSE,     cores = 2): The following params are not defined in this function: pu features dist_features threats dist_threats sensitivity boundary time_limit output_file cores print(s) #> Error: object 's' not found  ## Spatial example (conceptual): boundary derived from PU polygons stored by inputData() ## s2 <- mosap( ##   pu = pu_sf, features = feat_r, cost = cost_r, ##   boundary = \"auto\", ##   model_type = \"minimizeFragmentation\", ##   time_limit = 60 ## ) # }"},{"path":"https://josesalgr.github.io/mosap/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::[\\%>\\%][magrittr::pipe] details.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://josesalgr.github.io/mosap/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/plot.Solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a Solution (if spatial geometry is available) — plot.Solution","title":"Plot a Solution (if spatial geometry is available) — plot.Solution","text":"Plot solution using planning unit (PU) geometries available. method supports two views controlled : \"pu\": highlights selected planning units. \"actions\": highlights selected actions within planning units. Optionally, selected PUs selected action can labelled “conservation”. = \"actions\", function aggregates selected actions per PU single label concatenating unique action names using \"+\" (e.g., \"harvest+sustainable\"). many actions can co-occur PU, number distinct labels can grow quickly; cases, consider filtering single action via action = \"...\", ensure one action per PU.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/plot.Solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a Solution (if spatial geometry is available) — plot.Solution","text":"","code":"# S3 method for class 'Solution' plot(   x,   what = c(\"pu\", \"actions\"),   only_selected = FALSE,   action = NULL,   ...,   include_conservation = TRUE,   conservation_label = \"conservation\",   base_alpha = 0.1,   selected_alpha = 0.9,   base_fill = \"grey60\",   base_color = NA,   selected_color = NA,   fill_values = NULL,   fill_na = \"grey60\",   use_viridis = TRUE )"},{"path":"https://josesalgr.github.io/mosap/reference/plot.Solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a Solution (if spatial geometry is available) — plot.Solution","text":"x Solution object. must contain PU geometry sf object x$Data$data$pu_sf (preferred) x$data$pu_sf. Character string indicating plot. One \"pu\" \"actions\". only_selected Logical. used = \"pu\". TRUE, throw error selected PUs exist. FALSE, map still drawn base layer. action Optional character scalar. used = \"actions\". provided, filter plot single action label. ... Additional arguments (reserved future extensions). include_conservation Logical. used = \"actions\". TRUE, selected PUs selected action added map label conservation_label. conservation_label Character scalar. Label used selected PUs selected action include_conservation = TRUE. base_alpha Numeric \\([0,1]\\). Alpha used base PU layer. selected_alpha Numeric \\([0,1]\\). Alpha used highlighted (selected) geometries. base_fill Fill color base PU layer. base_color Border color base PU layer. Use NA border. selected_color Border color highlighted geometries. Use NA border. fill_values Optional named character vector colors. Names must match labels shown legend (.e., values action field used plot, including conservation_label enabled). provided, overrides viridis. fill_na Color used missing values manual scale (relevant fill_values provided). use_viridis Logical. TRUE fill_values NULL, use discrete viridis palette viridis installed.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/plot.Solution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a Solution (if spatial geometry is available) — plot.Solution","text":"Invisibly returns ggplot object. plot printed side effect.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/plot.Solution.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a Solution (if spatial geometry is available) — plot.Solution","text":"plotting method requires PU geometry stored sf object either x$Data$data$pu_sf x$data$pu_sf. geometry must contain id column matching planning unit identifiers. Colors = \"actions\" controlled either: fill_values: named vector mapping action labels colors; discrete viridis palette fill_values NULL, use_viridis = TRUE, viridis package installed.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/plot.Solution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a Solution (if spatial geometry is available) — plot.Solution","text":"","code":"if (FALSE) { # \\dontrun{ # Plot selected planning units plot(sol, what = \"pu\")  # Plot selected actions plot(sol, what = \"actions\")  # Plot a single action only plot(sol, what = \"actions\", action = \"harvest\")  # Manual colors for actions (and conservation) cols <- c(harvest = \"#E41A1C\", sustainable = \"#4DAF4A\", conservation = \"#377EB8\") plot(sol, what = \"actions\", fill_values = cols, conservation_label = \"conservation\") } # }"},{"path":"https://josesalgr.github.io/mosap/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print — print","title":"Print — print","text":"Displays information object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print — print","text":"","code":"# S3 method for class 'Data' print(x, ...)  # S3 method for class 'OptimizationProblem' print(x, ...)  # S3 method for class 'Solution' print(x, ...)  # S3 method for class 'Portfolio' print(x, ...)"},{"path":"https://josesalgr.github.io/mosap/reference/print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print — print","text":"x object. ... used.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print — print","text":"None.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure mathematical model (legacy-compatible preset) — problem","title":"Configure mathematical model (legacy-compatible preset) — problem","text":"Legacy-compatible helper stores model preset inside Data object. new pipeline, MILP built inside solve(). function create C++ model pointer; configures x$data$model_args .pa_build_model().","code":""},{"path":"https://josesalgr.github.io/mosap/reference/problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure mathematical model (legacy-compatible preset) — problem","text":"","code":"problem(   x,   model_type = c(\"minimizeCosts\", \"maximizeBenefits\"),   budget = 0,   blm = 0,   curve = 1,   segments = 3 )"},{"path":"https://josesalgr.github.io/mosap/reference/problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure mathematical model (legacy-compatible preset) — problem","text":"x Data object (class \"Data\") created inputData()/inputDataSpatial(). model_type character. \"minimizeCosts\" \"maximizeBenefits\". budget numeric. Stored model_args (compat/printing). blm numeric. Stored model_args (compat/printing). curve integer. Stored model_args (compat/printing). segments integer. Stored model_args (compat/printing).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure mathematical model (legacy-compatible preset) — problem","text":"Updated Data object preset stored x$data$model_args.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/register_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Register an atomic objective in an MOProblem — register_objective","title":"Register an atomic objective in an MOProblem — register_objective","text":"solve anything. records evaluate/build objective. Multi-objective methods (weighted, epsilon, etc.) use registry later.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/register_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register an atomic objective in an MOProblem — register_objective","text":"","code":"register_objective(   alias,   sense = c(\"min\", \"max\"),   build_fun,   eval_fun = NULL,   ... )"},{"path":"https://josesalgr.github.io/mosap/reference/register_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register an atomic objective in an MOProblem — register_objective","text":"alias character(1) unique objective identifier used MO methods. sense character(1) either \"min\" \"max\". build_fun function (data, ...) -> data_or_problem activates objective. now can store decide later whether returns new model pointer, objective vector, configured OptimizationProblem. eval_fun Optional function (solution, data, ...) -> numeric(1) evaluate objective value. ... Reserved future extensions. x MOProblem.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/register_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register an atomic objective in an MOProblem — register_objective","text":"function takes MOProblem (DSL x + ...) returns updated object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":null,"dir":"Reference","previous_headings":"","what":"Set multi-objective method: weighted sum — set_method_weighted","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"Configure weighted-sum multi-objective method top atomic objectives previously registered planning object. weighted-sum method combines multiple objectives single scalar objective: $$\\sum_{k \\K} w_k \\, f_k(x)$$ \\(f_k(x)\\) atomic objective (e.g., minimum cost, minimum fragmentation, maximum benefit) \\(w_k \\ge 0\\) user-supplied weights. function solve problem. stores multi-objective configuration inside \"MOProblem\" object can later used multi-objective solving workflow (e.g., weighted runs, epsilon-constraint, AUGMECON, interactive methods).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"","code":"set_method_weighted(x, aliases, weights, normalize = FALSE)"},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"x planning object (Data) existing \"MOProblem\". Data object provided, promoted \"MOProblem\" via .pamo_as_mo(). aliases character. Objective aliases combine (e.g. c(\"cost\",\"frag\")). alias must refer registered atomic objective. weights numeric. Non-negative weights, length aliases. normalize = TRUE, weights rescaled sum 1. normalize logical. TRUE, normalize weights sum 1.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"object x, promoted class \"MOProblem\", method configuration stored x$method:","code":"x$method <- list(   name = \"weighted\",   params = list(     aliases = <character>,     weights = <numeric>,     normalize = <logical>   ) )"},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"atomic-objectives-requirement","dir":"Reference","previous_headings":"","what":"Atomic objectives requirement","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"Weighted-sum requires base planning object contains one atomic objectives registered unique aliases. Atomic objectives registered calling objective setters alias argument, example: Internally, atomic objectives stored (convention) x$data$objectives[[alias]], entry including: objective_id: stable identifier (e.g., \"min_cost\", \"min_fragmentation\") model_type: builder identifier (used later materializing model) sense: \"min\" \"max\" objective_args: objective-specific arguments","code":"x <- x |>   add_objective_min_cost(alias = \"cost\") |>   add_objective_min_fragmentation(alias = \"frag\")"},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"objective-sense-min-vs-max-","dir":"Reference","previous_headings":"","what":"Objective sense (min vs max)","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"Combining objectives different senses (mixing \"min\" \"max\") requires standardization step multi-objective solving layer (e.g., converting maximization terms minimization terms negation shifting/scaling). function validates requested aliases exist; additional checks (e.g., forbidding mixed senses) can implemented .pamo_get_objective_specs() enforced later solver.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"weight-scaling-and-normalization","dir":"Reference","previous_headings":"","what":"Weight scaling and normalization","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"Weights must finite non-negative. normalize = TRUE, weights rescaled sum 1. Multiplying weights positive constant change optimizer’s solution pure weighted-sum formulation, can affect numerical conditioning.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"limitations-of-weighted-sums","dir":"Reference","previous_headings":"","what":"Limitations of weighted sums","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"Weighted sums typically recover supported Pareto-optimal solutions (convex hull Pareto front). Pareto front non-convex (common integer programs), efficient solutions obtained weight vector; consider epsilon-constraint AUGMECON methods cases.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_method_weighted.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set multi-objective method: weighted sum — set_method_weighted","text":"","code":"# \\donttest{ # ------------------------------------------------------------ # Example 1: Cost vs Fragmentation (both minimization) # ------------------------------------------------------------ pu <- data.frame(id = 1:4, cost = c(1, 2, 2, 3)) features <- data.frame(id = 1, name = \"sp1\") dist_features <- data.frame(pu = c(1,2,3,4), feature = 1, amount = c(1,1,1,1))  x <- inputData(pu = pu, features = features, dist_features = dist_features)  # (Optional) register a boundary relation used by fragmentation objectives bnd <- data.frame(   id1 = c(1,2,3,1,2,3,4),   id2 = c(1,2,3,2,3,4,4),   boundary = c(2,2,2,1,1,1,2) ) x <- add_spatial_boundary(x, boundary = bnd, name = \"boundary\")  # targets + atomic objectives x <- x |>   add_conservation_targets_relative(0.5) |>   add_objective_min_cost(alias = \"cost\") |>   add_objective_min_fragmentation(     alias = \"frag\",     relation_name = \"boundary\",     weight_multiplier = 0.01   )  # configure weighted sum mo <- set_method_weighted(   x,   aliases = c(\"cost\", \"frag\"),   weights = c(1, 1),   normalize = TRUE )  # Later (in your MO workflow): # sol <- solve(mo)   # ------------------------------------------------------------ # Example 2: Scan weights to explore trade-offs # ------------------------------------------------------------ weight_grid <- seq(0, 1, by = 0.25) mos <- vector(\"list\", length(weight_grid))  for (i in seq_along(weight_grid)) {   w <- weight_grid[i]   mos[[i]] <- set_method_weighted(     x,     aliases = c(\"cost\", \"frag\"),     weights = c(1 - w, w),     normalize = TRUE   )   # sols[[i]] <- solve(mos[[i]]) }   # ------------------------------------------------------------ # Example 3: Mixing max and min objectives (requires solver support) # ------------------------------------------------------------ # If your multi-objective solver standardizes senses, you can mix: # - a minimization objective (e.g., cost) # - a maximization objective (e.g., benefit) # # Otherwise, use epsilon-constraint or re-encode the objective. # # x2 <- x |> #   add_actions(actions_df) |> #   add_benefits(benefits_df) |> #   add_objective_min_cost(alias = \"cost\") |> #   add_objective_max_benefit(alias = \"benefit\") # mo2 <- set_method_weighted(x2, aliases = c(\"cost\",\"benefit\"), weights = c(1, 0.2)) # }"},{"path":"https://josesalgr.github.io/mosap/reference/set_solver.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure solver settings — set_solver","title":"Configure solver settings — set_solver","text":"Stores solver configuration inside Data object, solve(x) can run without repeating solver arguments. function build model; stores runtime solver options.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_solver.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure solver settings — set_solver","text":"","code":"set_solver(   x,   solver = c(\"auto\", \"gurobi\", \"cplex\", \"cbc\", \"symphony\"),   gap_limit = NULL,   time_limit = NULL,   solution_limit = NULL,   cores = NULL,   verbose = NULL,   name_output_file = NULL,   output_file = NULL,   solver_params = list(),   ... )"},{"path":"https://josesalgr.github.io/mosap/reference/set_solver.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure solver settings — set_solver","text":"x Data object created inputData() inputDataSpatial(). solver Character. One \"auto\", \"gurobi\", \"cplex\", \"cbc\", \"symphony\". gap_limit Numeric 0,1. Relative MIP optimality gap. NULL, keep stored value. time_limit Numeric. Time limit seconds. NULL, keep stored value. solution_limit Logical. NULL, keep stored value. cores Integer. NULL, keep stored value. verbose Logical. NULL, keep stored value. name_output_file Character. NULL, keep stored value. output_file Logical. NULL, keep stored value. solver_params List. Solver-specific parameters (merged stored ones). ... Convenience: solver-specific parameters (e.g., MIPFocus=1) merged solver_params.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/set_solver.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure solver settings — set_solver","text":"Updated Data object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/show.html","id":null,"dir":"Reference","previous_headings":"","what":"Show — show","title":"Show — show","text":"Display information object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/show.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show — show","text":"","code":"# S4 method for class 'Data' show(x)  # S4 method for class 'OptimizationProblem' show(x)  # S4 method for class 'Portfolio' show(x)"},{"path":"https://josesalgr.github.io/mosap/reference/show.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show — show","text":"x object.","code":""},{"path":[]},{"path":"https://josesalgr.github.io/mosap/reference/simData.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated multi-action planning data — simData","title":"Simulated multi-action planning data — simData","text":"Simulated data making prioritizations. sim_pu_data Planning units represented tabular data. sim_features_data Features represented tabular data. sim_dist_features_data simulated distribution four features. sim_threats_data Threats represented tabular data. sim_dist_threats_data simulated threats two threats. sim_sensitivity_data Sensitivity features threats tabular data. sim_boundary_data Boundary data one hundred planning units.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/simData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated multi-action planning data — simData","text":"","code":"data(sim_pu_data)  data(sim_features_data)  data(sim_dist_features_data)  data(sim_threats_data)  data(sim_dist_threats_data)  data(sim_sensitivity_data)  data(sim_boundary_data)"},{"path":"https://josesalgr.github.io/mosap/reference/simData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated multi-action planning data — simData","text":"sim_pu_data data.frame object. sim_features_data data.frame object. sim_dist_features_data data.frame object. sim_threats_data data.frame object. sim_dist_threats_data data.frame object. sim_sensitivity_data data.frame object. sim_boundary_data data.frame object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/simData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated multi-action planning data — simData","text":"","code":"if (FALSE) { # \\dontrun{ # load data data(sim_pu_data, sim_features_data, sim_dist_features_data, sim_threats_data, sim_dist_threats_data, sim_sensitivity_data, sim_boundary_data)  # plot examples library(raster) r <- raster::raster(ncol=10, nrow=10, xmn=0, xmx=10, ymn=0, ymx=10)  # plot cost of pu's values(r) <- sim_pu_data$monitoring_cost plot(r)  # plot feature distribution of feature 1 features <- tidyr::spread(data = sim_dist_features_data, key = feature, value = amount, fill = 0) values(r) <- features$'1' plot(r) } # }"},{"path":"https://josesalgr.github.io/mosap/reference/solution-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Solution class — solution-class","title":"Solution class — solution-class","text":"class used represent solution MIP (Mixed-Integer Programming) model. includes several methods obtain information optimization process solution associated planning units actions. created using solve() function.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/solution-class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solution class — solution-class","text":"return value.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/solution-class.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Solution class — solution-class","text":"$data list. Object containing data results optimization process.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/solution-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Solution class — solution-class","text":"print() Print basic information model solution. show() Call print method.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/solution-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solution class — solution-class","text":"","code":"# \\donttest{ # set seed for reproducibility set.seed(14)  ## Load data data(sim_pu_data, sim_features_data, sim_dist_features_data, sim_threats_data, sim_dist_threats_data, sim_sensitivity_data, sim_boundary_data)  ## Create data instance problem_data <- inputData(   pu = sim_pu_data, features = sim_features_data, dist_features = sim_dist_features_data,   threats = sim_threats_data, dist_threats = sim_dist_threats_data,   sensitivity = sim_sensitivity_data, boundary = sim_boundary_data ) #> Error in .pa_inputData_tabular_impl(pu = pu, features = features, dist_features = dist_features,     boundary = NULL, ...): formal argument \"boundary\" matched by multiple actual arguments  ## Create optimization model problem_model <- problem(x = problem_data, blm = 1) #> Error: object 'problem_data' not found  ## Solve the optimization model s <- solve(a = problem_model, time_limit = 5, output_file = FALSE, cores = 2) #> Error: object 'problem_model' not found  ## Use class methods  s$print() #> Error: object 's' not found # }"},{"path":"https://josesalgr.github.io/mosap/reference/solve.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve optimization model — solve","title":"Solve optimization model — solve","text":"Solves model defined Data object. Solver configuration read x$data$solve_args (typically set via set_solver() / set_solver_*()).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/solve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve optimization model — solve","text":"","code":"solve(x, ...)"},{"path":"https://josesalgr.github.io/mosap/reference/solve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve optimization model — solve","text":"x Data object created inputData() inputDataSpatial(). ... Optional legacy solver arguments (deprecated).","code":""},{"path":"https://josesalgr.github.io/mosap/reference/solve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve optimization model — solve","text":"Solution object.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/targets.html","id":null,"dir":"Reference","previous_headings":"","what":"Targets API — targets","title":"Targets API — targets","text":"Functions define feature-level targets planning problem. Targets stored x$data$targets later translated mathematical constraints optimization model built. API supports three target types: Conservation Ensure baseline representation selected planning units reaches threshold. Recovery Ensure action-driven improvements (deltas) reach threshold. Mixed total Ensure baseline + action deltas together reach single threshold. target stored row least: feature, type, sense, target_unit, target_raw, basis_total, target_value, optional metadata label created_at.","code":""},{"path":"https://josesalgr.github.io/mosap/reference/targets.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Targets API — targets","text":"Targets format. targets argument can provided multiple equivalent ways (implemented .pa_parse_targets()), typically including: single numeric value recycled features, numeric vector aligned feature order, named numeric vector names identify features, data.frame feature identifiers target values. Features may identified numeric id /feature name column supported .pa_parse_targets(). Absolute vs relative targets. Absolute targets set target_value directly provided targets. Relative targets treat targets proportions \\([0,1]\\) convert absolute thresholds multiplying feature-specific basis: Conservation relative targets use baseline totals (via .pa_feature_totals()). Recovery relative targets use either potential improvement (via .pa_feature_potential()) baseline totals, depending relative_basis. Mixed-total relative targets use baseline totals (via .pa_feature_totals()). chosen basis stored basis_total, resulting absolute threshold stored target_value. Mutual exclusivity mixed-total targets. Mixed-total targets represent single threshold baseline + deltas feature: $$\\sum_i z_{} r_{} + \\sum_{,} x_{ia}\\Delta_{ias} \\ge T^{mix}_s.$$ differs enforcing separate conservation recovery targets, mixed-total targets intended mutually exclusive conservation/recovery targets feature. (Enforcement handled .pa_store_targets()). Overwrite behavior. overwrite=TRUE, existing targets type feature(s) can replaced. overwrite=FALSE, adding targets features already targets type typically error (exact behavior handled .pa_store_targets()).","code":""}]
