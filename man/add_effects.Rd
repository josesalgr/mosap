% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/add_effects.R
\name{add_effects}
\alias{add_effects}
\title{Add effects (benefit/loss) to a planning problem}
\usage{
add_effects(
  x,
  effects = NULL,
  effect_type = c("delta", "after"),
  effect_aggregation = c("sum", "mean"),
  align_rasters = TRUE,
  keep_zero = FALSE,
  drop_locked_out = TRUE,
  na_to_zero = TRUE,
  filter = c("any", "benefit", "loss")
)
}
\arguments{
\item{x}{A \code{Data} object created with \code{\link{inputData}} or \code{\link{inputDataSpatial}}.
Must contain \code{x$data$dist_actions} (run \code{\link{add_actions}} first).}

\item{effects}{Effect specification. One of:
\itemize{
\item \code{NULL}: store an empty effects table.
\item \code{data.frame(action, feature, multiplier)}: apply signed multipliers to baseline amounts.
\code{feature} may be feature ids or feature names (matching \code{x$data$features$name}).
\item \code{data.frame(pu, action, feature, ...)}: explicit effects with one of:
\itemize{
\item \code{delta} (signed) or \code{effect} (signed),
\item \code{after} (after-action amount; set \code{effect_type = "after"}),
\item \code{benefit} and/or \code{loss} (both non-negative; missing component treated as 0),
\item legacy signed \code{benefit} without \code{loss} (treated as signed delta).
}
\item A named list of \code{terra::SpatRaster} objects: names = action ids; one layer per feature.
}}

\item{effect_type}{Character. How to interpret provided values for explicit tables or raster lists:
\itemize{
\item \code{"delta"}: values represent signed deltas (default),
\item \code{"after"}: values represent after-action amounts (converted to deltas using baseline).
}}

\item{effect_aggregation}{Character. Aggregation used to compute PU-level values from rasters.
One of \code{"sum"} or \code{"mean"}.}

\item{align_rasters}{Logical. If \code{TRUE}, attempt to align effect rasters to the PU raster grid
before zonal operations (default \code{TRUE}).}

\item{keep_zero}{Logical. If \code{TRUE}, keep rows where \code{benefit == 0} and \code{loss == 0}.
Default \code{FALSE}.}

\item{drop_locked_out}{Logical. If \code{TRUE}, drop rows for \code{(pu, action)} pairs with
\code{status == 3} in \code{x$data$dist_actions} (if the column exists). Default \code{TRUE}.}

\item{na_to_zero}{Logical. If \code{TRUE}, treat missing values as 0 when computing benefit/loss.
Default \code{TRUE}.}

\item{filter}{Character. Filter rows by non-zero component:
\itemize{
\item \code{"any"}: keep both benefit and loss rows (default),
\item \code{"benefit"}: keep only rows with \code{benefit > 0},
\item \code{"loss"}: keep only rows with \code{loss > 0}.
}}
}
\value{
The updated \code{Data} object with \code{x$data$dist_effects} created/updated, and
metadata stored in \code{x$data$effects_meta}.
}
\description{
Define the ecological (or any feature-based) effects of implementing actions in planning units.
Effects are stored in \code{x$data$dist_effects} as two non-negative components per
feasible \code{(pu, action, feature)} triple:
\itemize{
\item \code{benefit} \eqn{\ge 0}: positive change (improvement),
\item \code{loss} \eqn{\ge 0}: magnitude of negative change (damage), computed as
\code{loss = -min(delta, 0)}.
}
}
\details{
Internally, effects may originate from signed values (deltas) or from after-action amounts.
Regardless of input, \code{dist_effects} always stores \code{benefit} and \code{loss} as
non-negative values to avoid ambiguity and to support models that separately account for
gains and damages.

\strong{Baseline and after-action amounts.}
If \code{effect_type = "after"}, provided values are interpreted as after-action amounts and
converted to signed deltas using the baseline amounts in \code{x$data$dist_features$amount}:
\deqn{\mathrm{delta} = \mathrm{after} - \mathrm{baseline}.}
Missing baseline values are treated as 0.

\strong{Supported effect specifications.}
\enumerate{
\item \emph{NULL}: store an empty effects table (recommended default when effects are not available yet).
\item \emph{Multipliers}: a \code{data.frame(action, feature, multiplier)} that applies a signed multiplier to
baseline amounts: \eqn{\mathrm{delta} = \mathrm{amount} \times \mathrm{multiplier}}.
\item \emph{Explicit rows}: a \code{data.frame(pu, action, feature, ...)} providing either signed deltas
(\code{delta} or \code{effect}, or legacy signed \code{benefit}), after-action amounts (\code{after}),
or already split non-negative \code{benefit}/\code{loss}.
\item \emph{Rasters per action}: a named list of \code{terra::SpatRaster} objects (names are action ids),
each with one layer per feature. Raster values are aggregated by planning unit using
\code{effect_aggregation} and then interpreted as deltas or after-action amounts depending on \code{effect_type}.
}

\strong{Feasibility and locks.}
Effects are retained only for feasible \code{(pu, action)} pairs present in \code{x$data$dist_actions}.
If \code{drop_locked_out = TRUE} and \code{x$data$dist_actions$status} exists, pairs with \code{status == 3}
are excluded before effects are processed.

\strong{Filtering.}
You can keep only beneficial effects (\code{benefit > 0}) or only losses (\code{loss > 0}) using \code{filter}.
By default, rows with both \code{benefit == 0} and \code{loss == 0} are dropped unless \code{keep_zero = TRUE}.
}
\examples{
\dontrun{
# 1) Empty effects (default)
p <- add_effects(p, effects = NULL)

# 2) Multipliers (action x feature): delta = amount * multiplier
mult <- data.frame(
  action = c("harvest", "harvest", "restoration"),
  feature = c("sp1", "sp2", "sp1"),      # feature names (requires x$data$features$name)
  multiplier = c(-0.2, -0.1, 0.3)
)
p <- add_effects(p, effects = mult, effect_type = "delta")

# 3) Explicit deltas by (pu, action, feature)
eff <- data.frame(
  pu = c(1, 1, 2),
  action = c("harvest", "harvest", "restoration"),
  feature = c(1, 2, 1),
  delta = c(-0.5, 0.2, 1.0)
)
p <- add_effects(p, effects = eff)

# 4) After-action amounts (converted to delta = after - baseline)
after_tbl <- transform(eff, after = delta) # example only; typically after is an absolute amount
p <- add_effects(p, effects = after_tbl, effect_type = "after")

# 5) Raster effects per action (one layer per feature)
# effects_rasters <- list(harvest = r_harv, restoration = r_rest) # terra::SpatRaster
# p <- add_effects(p, effects = effects_rasters, effect_type = "delta", effect_aggregation = "sum")

# Keep only beneficial effects
p <- add_effects(p, effects = eff, filter = "benefit")
}

}
\seealso{
\code{\link{add_benefits}}, \code{\link{add_losses}}
}
