% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MOproblem-class.R
\name{register_objective}
\alias{register_objective}
\title{Register an atomic objective in an MOProblem}
\usage{
register_objective(
  alias,
  sense = c("min", "max"),
  build_fun,
  eval_fun = NULL,
  ...
)
}
\arguments{
\item{alias}{\code{character(1)} unique objective identifier used by MO methods.}

\item{sense}{\code{character(1)} either "min" or "max".}

\item{build_fun}{A function \verb{(data, ...) -> data_or_problem} that activates this objective.
For now you can store it and decide later whether it returns a new model pointer,
an objective vector, or a configured \code{OptimizationProblem}.}

\item{eval_fun}{Optional function \verb{(solution, data, ...) -> numeric(1)} to evaluate objective value.}

\item{...}{Reserved for future extensions.}

\item{x}{\code{MOProblem}.}
}
\value{
A function that takes an \code{MOProblem} (for DSL \code{x + ...}) and returns the updated object.
}
\description{
This does not solve anything. It only records how to evaluate/build the objective.
Multi-objective methods (weighted, epsilon, etc.) will use this registry later.
}
\keyword{internal}
