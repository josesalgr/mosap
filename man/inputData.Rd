% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inputData.R
\name{inputData}
\alias{inputData}
\alias{inputData,data.frame,data.frame,data.frame-method}
\alias{inputData,ANY,ANY,missing-method}
\alias{inputData,ANY,ANY,NULL-method}
\title{Create a planning problem input object}
\usage{
inputData(
  pu,
  features,
  dist_features,
  cost = NULL,
  pu_id_col = "id",
  locked_in_col = "locked_in",
  locked_out_col = "locked_out",
  pu_status = NULL,
  cost_aggregation = c("mean", "sum"),
  ...
)

\S4method{inputData}{data.frame,data.frame,data.frame}(
  pu,
  features,
  dist_features,
  cost = NULL,
  pu_id_col = "id",
  locked_in_col = "locked_in",
  locked_out_col = "locked_out",
  pu_status = NULL,
  cost_aggregation = c("mean", "sum"),
  ...
)

\S4method{inputData}{ANY,ANY,missing}(
  pu,
  features,
  dist_features,
  cost = NULL,
  pu_id_col = "id",
  locked_in_col = "locked_in",
  locked_out_col = "locked_out",
  pu_status = NULL,
  cost_aggregation = c("mean", "sum"),
  ...
)

\S4method{inputData}{ANY,ANY,NULL}(
  pu,
  features,
  dist_features,
  cost = NULL,
  pu_id_col = "id",
  locked_in_col = "locked_in",
  locked_out_col = "locked_out",
  pu_status = NULL,
  cost_aggregation = c("mean", "sum"),
  ...
)
}
\arguments{
\item{pu}{Planning units input. Either:
\itemize{
\item a \code{data.frame} with an \code{id} column (tabular mode),
\item a spatial vector (\code{terra::SpatVector}, \code{sf}, or a vector file path) (vector-PU mode), or
\item a raster (\code{terra::SpatRaster} or raster file path) used as a mask/template (raster-cell mode).
}}

\item{features}{Features input. Either:
\itemize{
\item a \code{data.frame} with \code{id} (and optionally \code{name}) (tabular mode), or
\item a raster stack with one layer per feature (\code{terra::SpatRaster} or file path)
(vector-PU mode or raster-cell mode).
}}

\item{dist_features}{Distribution of features. A \code{data.frame} with columns \code{pu}, \code{feature},
and \code{amount}. If missing or \code{NULL}, spatial workflows derive it automatically.}

\item{cost}{In spatial modes, required. Either a column name in the PU vector attribute table
(vector-PU mode) or a raster/file path (vector-PU or raster-cell mode). In raster-cell mode,
cells with \code{cost <= 0} or \code{NA} are excluded (no PU is created).}

\item{pu_id_col}{For vector-PU mode, the name of the id column in the PU layer.}

\item{locked_in_col}{For vector-PU mode, the name of a logical column indicating locked-in PUs.}

\item{locked_out_col}{For vector-PU mode, the name of a logical column indicating locked-out PUs.}

\item{pu_status}{Optional (vector-PU or raster-cell) status input. Either a column name or a raster/file path.
Values \code{2} mark locked-in and \code{3} mark locked-out (Marxan-style).}

\item{cost_aggregation}{In vector-PU mode, how to aggregate raster cell costs to polygons when \code{cost} is a raster.
Either \code{"mean"} or \code{"sum"}.}

\item{...}{Additional arguments forwarded to internal builders.}
}
\value{
A \code{Data} object used by downstream functions (\verb{add_*()}, \code{set_solver()}, \code{solve()}, etc.).
}
\description{
Builds a \code{Data} object from either tabular inputs or spatial inputs.
This is the entry point for the \strong{mosap} workflow.

The function supports three input styles:
\enumerate{
\item \strong{Tabular mode}: If \code{pu}, \code{features}, and \code{dist_features} are \code{data.frame}s,
a purely tabular workflow is used (no spatial packages required).
\item \strong{Vector-PU spatial mode}: If \code{dist_features} is missing (or \code{NULL}) and \code{pu} is
a spatial vector (e.g. \code{terra::SpatVector}, \code{sf}, a vector file path), while
\code{features} is a raster stack (one layer per feature), then feature amounts are
aggregated by polygon (default \code{sum}) and stored as \code{dist_features}.
\item \strong{Raster-cell fast mode}: If \code{dist_features} is missing (or \code{NULL}) and \code{pu} and
\code{features} are rasters (e.g. \code{terra::SpatRaster} or raster file paths), then each
valid raster cell becomes a planning unit. In this mode:
\itemize{
\item cells are valid if \code{cost} is finite and \code{cost > 0}
\item \code{pu} is used as a mask/template (cells with \code{NA} in \code{pu} are excluded)
This avoids raster-to-polygon conversion and is substantially faster for large grids.
}
}
}
\details{
\strong{Spatial relations are not created automatically.}
This version of \code{inputData()} does \emph{not} take a \code{boundary} argument.
Spatial relations (boundary/rook/queen/kNN/distance) must be registered explicitly
after \code{inputData()} using \code{add_spatial_boundary()}, \code{add_spatial_rook()},
\code{add_spatial_queen()}, \code{add_spatial_knn()}, \code{add_spatial_distance()}, or
\code{add_spatial_relations()}.

In raster-cell mode you typically build relations from coordinates with
\code{add_spatial_knn()} or \code{add_spatial_distance()}.
}
\examples{
\dontrun{
# ------------------------------------------------------
# 1) Tabular mode
# ------------------------------------------------------
pu <- data.frame(id = 1:3, cost = c(1, 2, 3))
features <- data.frame(id = 1:2, name = c("sp1", "sp2"))
dist_features <- data.frame(
  pu = c(1, 1, 2, 3),
  feature = c(1, 2, 2, 1),
  amount = c(1, 5, 2, 1)
)

x <- inputData(pu = pu, features = features, dist_features = dist_features)

# Optional: register a spatial relation later (if you need spatial objectives)
rel <- data.frame(pu1 = 1, pu2 = 2, weight = 1)
x <- add_spatial_relations(x, rel, name = "rook_like")


# ------------------------------------------------------
# 2) Raster-cell fast mode (1 PU per valid cell)
# ------------------------------------------------------
library(terra)
pu_mask <- rast("pu_mask.tif")           # NA outside study area
cost_r  <- rast("cost.tif")              # cost per cell
feat_r  <- rast(c("sp1.tif", "sp2.tif")) # layers = features

x <- inputData(pu = pu_mask, features = feat_r, cost = cost_r)

# Optional: add spatial relations after inputData (e.g., kNN)
x <- add_spatial_knn(x, k = 8, name = "knn8", weight_fn = "inverse")


# ------------------------------------------------------
# 3) Vector-PU spatial mode (polygons + raster features)
# ------------------------------------------------------
pu_v   <- vect("pus.gpkg")               # polygon PUs
feat_r <- rast(c("sp1.tif", "sp2.tif"))  # features as raster layers
cost_r <- rast("cost.tif")               # raster cost (aggregated to polygons)

x <- inputData(
  pu = pu_v,
  features = feat_r,
  cost = cost_r,
  pu_id_col = "id",
  cost_aggregation = "mean"
)

# Add boundary-length relation explicitly (requires sf)
x <- add_spatial_boundary(x, pu_sf = x$data$pu_sf, name = "boundary")
}

}
